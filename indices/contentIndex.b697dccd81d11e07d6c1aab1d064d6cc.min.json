{"/":{"title":"Cleanpedia","content":"\n## Introduction\n\nThe motivation of this reference is to create an accessible, concise, and clear documentation for those who are seeking to learn CLEAN.\n\nThe same information can be found on:\n\n- [Cloogle](https://cloogle.org/) which is the languageâ€™s search engine, and\n- [language report](https://cloogle.org/doc/) which describes the syntax and BNF of Clean.\n\nHowever, this documentation is not official.\nTerminologies and explanations may not be entirely true to the references used.\n\nIn addition, the language report, which was the primary source of this documentation, was written for the version 2.0 of CLEAN.\n\nIf you notice any mistake or have suggestions for improvements, please feel free to contact me through the following channels:\n\n- Email: [b9xp3x@inf.elte.hu](mailto:b9xp3x@inf.elte.hu)\n- Instagram: [@\\_kornthana](https://www.instagram.com/_kornthana/)\n- Telegram channel: [https://t.me/+El6CtwOD8KxhYmU9](https://t.me/+El6CtwOD8KxhYmU9)\n\n---\n\n## Functions\n\nIn this section, we discuss how functions, operators, and constants are defined.\n\nStart reading: [Defining a Function](function/Defining%20a%20Function.md)\n\n---\n\n## Built-In Types\n\nTypes like integers, Booleans, characters, real numbers, lists, tuples, and arrays are frequently used.\nThey have been predefined for reasons of efficiency and convenience.\n\nThere are four built-in primitive types:\n- integer type,\n- real number type,\n- Boolean type, and\n- character type.\n\nThere are three built-in structured types:\n- list type,\n- array type, and\n- tuple type.\n\n### Integers\n\n#### Constructing Integers\n\nThere are three methods to construct integer literals;\n- from decimal notation,\n- from octal notation, and\n- from hexadecimal notation.\n\nInteger literals constructed with decimal notation may be written as follows.\n\n```\n// Language: Clean\n\n-13\n 0\n 13\n```\n\nInteger literals constructed with octal notation may be written by prefixing octal digits with `0`.\n\n```\n// Language: Clean\n\n-015  // decimal -13\n 0\n 015  // decimal  13\n```\n\nIntegers literals constructed with hexadecimal notation may be written by prefixing hexadecimal digits with `0x`.\n\n```\n// Language: Clean\n\n-0xD  // decimal -13\n 0\n 0xd  // decimal  13\n```\n\n#### Typing Integers\n\nAn expression of integer type may be explicitly typed using `Int`.\n\n```\n// Language: Clean\n\nexpr :: Int\nexpr =  1 + 1\n```\n\n#### Integer Operators And Functions\n\nInteger operations and functions are discussed in more details on [Appendix A: StdInt](appendix-a/stdint).\n\n### Real Numbers\n\n#### Constructing Real Number\n\nThere are two methods to construct real number literals;\n- from decimal notation, and\n- from scientific notation.\n\nReal number literals constructed with decimal notation may be written as follows.\n\n\n```\n// Language: Clean\n\n-1.3\n 0.0\n 1.3\n```\n\nReal number literals constructed with scientific notation may be written using `..E..` form.\n\n```\n// Language: Clean\n\n-13E-2  // -0.13\n 0E0    //  0\n 13E-2  //  0.13\n```\n\nWhen constructing a real number literal with scientific notation, the expression may result in an integer instead of a real number.\n\n```\n// Language: Clean\n\n13E2  // 1300\n```\n\n#### Typing Real Numbers\n\nAn expression of real number type may be explicitly typed using `Real`.\n\n```\n// Language: Clean\n\nexpr :: Real\nexpr =  1.0 + 1.0\n```\n\n#### Real Number Operators And Functions\n\nReal number operations and functions are discussed in more details on [Appendix A: StdReal](appendix-a/stdreal).\n\n### Booleans\n\n#### Constructing Booleans\n\nThere are two methods to construct Boolean literals.\nEach constructor represent a Boolean value.\n\n```\n// Language: Clean\n\nTrue\nFalse\n```\n\n#### Typing Booleans\n\nAn expression of Boolean type may be explicitly typed using `Bool`.\n\n```\n// Language: Clean\n\nexpr :: Bool\nexpr =  1 == 1\n```\n\n#### Boolean Operations and Functions\n\nBoolean operations and functions are discussed in more details on [Appendix A: StdBool](appendix-a/stdbool).\n\n### Characters\n\n#### Constructing Characters\n\nA character may be constructed by placing one character inside a pair of single quotation marks (`'..'`).\n\nCharacters constructed in the same way.\n\n```\n// Language: Clean\n\n'a'\n'9'\n'Z'\n'+'\n```\n\n#### Typing Characters\n\nAn expression of character type may be explicitly typed using `Char`.\n\n```\n// Language: Clean\n\nexpr :: Char\nexpr =  'a'\n```\n\n#### Character Operations And Functions\n\nCharacter operations and functions are discussed in more details on [Appendix A: StdChar](appendix-a/stdchar).\n\n### Lists\n\n**Type annotation**:\n`[Int]`,\n`[Char]`,\n`[T]`,\net cetera.\n\n#### Constructing Lists\n\nA list can be constructed in many ways, but there are three primary methods.\nThe simplest way to construct a list is to explicitly write elements between a pair of square brackets (`[..]`).\n\n```\n// Language: Clean\n\n[1]\n```\n\nElements are comma (`,`) separated.\n\n```\n// Language: Clean\n\n[1, 2, 3]\n```\n\nA list may be appended to the end of another list using colon (`:`).\n\n```\n// Language: Clean\n\n[1 : [2, 3]]\n```\n\nThe outer list (`[1 : ..]`) is constructed by appending the inner list (`[2, 3]`) to the end.\n\nAs a result, this method of list construction has a wide varieties which can be written.\n\n```\n// Language: Clean\n\n[1 : [2 : [3 : []]]]\n[1, 2 : [3]]\n[1, 2, 3 : []]\n```\n\nSecondly, a list may be implicitly constructed with `dot-dot` expression, and a control expression may be written as follows.\n\n```\n// Language: Clean\n\n[initial..]\n```\n\nAn infinite list is generated from `initial`, which represents the starting value, subsequent elements are incremented by one.\n\n```\n// Language: Clean\n\n[1..]  // [1, 2, 3, 4, ...]\n```\n\nTo create a finite list, an `end` value may be specified.\n\n```\n// Language: Clean\n\n[initial..end]\n```\n\nBy adding `end`, elements are generated only up to `end` it self.\n\n```\n// Language: Clean\n\n[1..5]  // [1, 2, 3, 4, 5]\n```\n\nIn addition, `next` value may be specified to change how subsequent elements are generated.\n\n```\n// Language: Clean\n\n[initial, next..end]\n```\n\nEach step is computed from `next - initial`.\nIf the next element is strictly greater than `end`, it will not be included.\nIt is possible to generate a list which is in descending order.\n\n```\n// Language: Clean\n\n[1, 3..9]  // [1, 3, 5, 7, 9]\n[5, 4..1]  // [5, 4, 3, 2, 1]\n```\n\nBy omitting `end`, an infinite list with step may be generated.\n\n```\n// Language: Clean\n\n[initial, next..]\n```\n\nThe expression results in an infinite list.\n\n```\n// Language: Clean\n\n[1, 3..]  // [1, 3, 5, 7, 9, ...]\n[5, 4..]  // [5, 4, 3, 2, 1, ...]\n```\n\nIt should be noted that `dot-dot` expressions requires `StdEnum` module.\n\nAnd lastly, a list may be constructed with comprehension.\n\n```\n// Language: Clean\n\n// extract from a list\n[el \\\\ el \u003c- list]\n\n// extract from an array\n[el \\\\ el \u003c-: array]\n\n// cartesian product\n[(x, y) \\\\ x \u003c- xs , y \u003c- ys]\n\n// pair-wise zip\n[(x, y) \\\\ x \u003c- xs \u0026 y \u003c- ys]\n\n// same as filter\n[x \\\\ x \u003c- xs | P x]\n\n// nested\n[(x, y) \\\\ x \u003c- xs, y \u003c- [1..x]]\n```\n\nA special notation for constructing a list of characters is also provided:\n\n```\n// Language: Clean\n\n['a', 'b', 'c']\n['abc']\n['ab','c']\n```\n\nA list may contain an infinite number of elements, but elements must have the same type.\n\nMore information about built-in operations and functions on lists can be found on:\n\n- [Appendix A: StdCharList](appendix-a/stdcharlist),\n- [Appendix A: StdList](appendix-a/stdlist), and\n- [Appendix A: StdOrdList](appendix-a/stdordlist).\n\n**List patterns**\n\nLists can be specified as patterns as follow:\n\n```\n// Language: Clean\n\ngetFst :: [T]       -\u003e T\ngetFst    [x, y, z] =  x\n\ngetSnd :: [T]       -\u003e T\ngetSnd    [x, y, z] =  y\n\ngetThd :: [T]       -\u003e T\ngetThd    [x, y, z] =  z\n```\n\nThe results of these function calls are as expected:\n\n```\n// Language: Clean\n\ngetFst [1, 2, 3]  // 1\ngetSnd [1, 2, 3]  // 2\ngetThd [1, 2, 3]  // 3\n```\n\nHowever, they will result in a run-time error if it is invoked with a list which does not have exactly three elements.\n\n```\n// Language: Clean\n\ngetFst [1]          // NOT OK :(\ngetSnd [1, 2]       // NOT OK :(\ngetThd [4, 3, 2, 1] // NOT OK :(\n```\n\nTo remedy this issue, an addition element should be introduce.\n\n```\n// Language: Clean\n\ngetFstAny :: [T]     -\u003e T\ngetFstAny    [x : r] =  x\n\ngetSndAny :: [T]        -\u003e T\ngetSndAny    [x, y : r] =  y\n\ngetThdAny :: [T]           -\u003e T\ngetThdAny    [x, y, z : r] =  z\n```\n\nThe right-hand side of colon ($:$) matches with any number of elements, including zero.\nIt is worth noting that $r$ is always a list.\n\n```\n// Language: Clean\n\ngetFstAny [1]           // x = 1\n                        // r = []\n\ngetFstAny [1, 2]        // x = 1\n                        // r = [2]\n\ngetFstAny [4, 3, 2, 1]  // x = 4\n                        // r = [3, 2, 1]\n```\n\nHowever, the second function still requires the list to have at least two elements.\n\n```\n// Language: Clean\n\ngetSndAny [1]           // NOT OK :(\n\ngetSndAny [1, 2]        // x = 1\n                        // y = 2\n                        // r = []\n\ngetSndAny [4, 3 ,2 ,1]  // x = 4\n                        // y = 3\n                        // r = [2, 1]\n```\n\nSimilarly, the third function requires a list with at least three elements.\n\n```\n// Language: Clean\n\ngetThdAny [1]           // NOT OK :(\n\ngetThdAny [1, 2]        // NOT OK :(\n\ngetThdAny [4, 3, 2, 1]  // x = 4\n                        // y = 3\n                        // z = 2\n                        // r = [1]\n```\n\n### Tuples\n\n#### Defining A Tuple\n\n**Type annotation**:\n$(\\textbf{T},\\ \\textbf{K})$,\n$(\\textbf{T},\\ \\textbf{K},\\ \\textbf{V})$,\n$(\\textbf{T},\\ \\textbf{K},\\ \\textbf{V},\\ \\textbf{E})$\net cetera.\n\nA tuple contains finite number of elements.\nElements do not have to be the same type.\nEvery type appears in a tuple must be specified, and singleton tuples are not allowed.\n\n**Constructors**\n\n```\n// Language: Clean\n\nA :: (Int, Char)\nA =  (49, '1')\n\nB :: (Real, Bool, String)\nB =  (0.2, False, \"Hi\")\n\nC :: (Int)\nC =  (2, 6)  // NOT OK should be (Int, Int)\n\nD :: (Int)\nD =  (2)     // NOT OK\n```\n\nMore information about built-in operations and functions on lists can be found on:\n\n- [Appendix A: StdTuple](appendix-a/stdtuple).\n\n#### Tuple Patterns\n\nTuples can be used as patterns in a similar way to lists.\nHowever, colon ($:$) is not allowed in tuple patterns.\n\n```\n// Language: Clean\n\ngetFst :: (T, K, V) -\u003e T\ngetFst    (x, y, z) =  x\n\ngetSnd :: (T, K, V) -\u003e K\ngetSnd    (x, y, z) =  y\n\ngetThd :: (T, K, V) -\u003e V\ngetThd    (x, y, z) =  z\n```\n\nThe results of these function calls are as expected:\n\n```\n// Language: Clean\n\ngetFst (1, 'a', 1.0)  // 1\ngetSnd (1, 'a', 1.0)  // 'a'\ngetThd (1, 'a', 1.0)  // 1.0\n```\n\n### Arrays\n\n#### Defining An Array\n\n**Type annotation**:\n$\\{\\textbf{Int}\\}$,\n$\\{\\textbf{Char}\\}$,\n$\\{\\textbf{T}\\}$,\net cetera.\n\nAn array contains a finite number of elements.\nElements of an array have to be of the same type.\n\n**Constructors**\n\n```\n// Language: Clean\n\n{1, 2, 3, 4}\n{1.0, 2.0, 3.0, 4.0}\n\n\"abc\"\n// equivalent to\n// {'a', 'b', 'c'}\n```\n\nAn array can be constructed from comprehension by surrounding a comprehension with $\\{\\ldots\\}$.\n\nMore information about built-in operations and functions on lists can be found on:\n\n- [Appendix A: StdArray](appendix-a/stdarray), and\n- [Appendix A: StdString](appendix-a/stdstring).\n\n---\n\n## Defining New Types\n\nAs a strongly typed language, every object and function in CLEAN has a type.\nThe basic can be extended with algebraic types, record types, abstract types and synonym types.\n\nNew types can only be defined on the global level.\n\n### Algebraic Data Types\n\n#### Defining An Algebraic Data Type\n\nAn algebraic data type introduces a new data structure and a constructor.\n\nIt has the following syntax.\n\n```\n// Language: Clean\n\n:: [tName] = [tConstructor]\n```\n\nAn algebraic data type can have multiple constructors.\nConstructors defined in the same global scope must have names.\nConstructors must be separated by a vertical bar ($|$).\n\n```\n// Language: Clean\n\n:: [tName] = [tConstructorA] | [tConstructorB] | [tConstructorC]\n```\n\nFor readability, constructors may be placed on different lines.\n\n```\n// Language: Clean\n\n:: [tName] = [tConstructorA]\n           | [tConstructorB]\n           | [tConstructorC]\n```\n\nFor example, a basic algebraic type can be defined as follows.\n\n```\n// Language: Clean\n\n:: Mood = Happy | Sad\n```\n\nConstructors also accept types as arguments, but they must be declared on the left-hand side.\nOnce declared, these generic types can be referred to by any of its constructors.\n\n```\n// language: Clean\n\n:: [tName] T K = [tConstructorA] T\n               | [tConstructorB] K\n               | [tConstructorC] T K\n```\n\nFor example, a binary tree, which is has a recursive structure can be defined as follows.\n\n```\n// language: Clean\n\n:: Tree = Branch Tree Tree\n        | Leaf\n```\n\nAn infix constructor is defined by surrounding its name with parentheses.\nThey must have an arity of two.\nThe precedence and fixity of an such constructor follows that of an operator, which is discussed in Chapter I.\n\n```\n// Language: Clean\n\n:: [tName] T K =  [tConstructorA]  T\n               |  [tConstructorB]  K\n               | ([tConstructorC]) T K\n\n:: [tName] T K =  [tConstructorA]  T\n               |  [tConstructorB]  K\n               | ([tConstructorC]) [fixity] [precedence] T K\n```\n\nFor example, the $\\text{Branch}$ constructor can be rewritten as an infix constructor.\n\n```\n// language: Clean\n\n:: TreeInfix = (/\\) infixr 0 Tree Tree\n             | Leaf\n```\n\nThe precedence and fixity of an infix constructor can be omitted.\nThe default precedence is $9$, and the default fixity is $\\textbf{infixl}$.\n\n```\n// language: Clean\n\n:: TreeInfix = (/\\) Tree Tree\n             | Leaf\n```\n\n#### Creating Objects Of Algebraic Data Types\n\nObjects of simple algebraic data types are created by invoking one of its constructors.\n\n```\n// Language: Clean\n\n:: Mood = Sad | Happy\n\nA :: Mood\nA =  Happy\n\nB :: Mood\nB =  Sad\n```\n\nIf a constructor accepts arguments, it should be invoked with appropriate arguments.\n\n```\n// Language: Clean\n\n:: Tree = Branch Tree Tree\n        | Leaf\n\nA :: Tree\nA =  Leaf\n\nB :: Tree\nB =  Branch Leaf Leaf\n\nC :: Tree\nC =  Branch Leaf (Branch Leaf Leaf)\n```\n\nInfix constructors behave in a similar way.\n\n```\n// language: Clean\n\n:: TreeInfix = (/\\) TreeInfix TreeInfix\n               | Leaf\n\nA :: TreeInfix\nA =  Leaf\n\nB :: TreeInfix\nB =  Leaf /\\ Leaf\n\nC :: TreeInfix\nC =  (/\\) Leaf Leaf\n\nD :: TreeInfix\nD =  Leaf /\\ (Leaf /\\ Leaf)\n```\n\n#### Algebraic Data Type Patterns\n\nTo use a algebraic data type as a pattern, use its constructors.\n\n```\n// Language: Clean\n\n:: Mood = Sad | Happy\n\nisHappy :: Mood    -\u003e Bool\nisHappy    (Happy) =  True\nisHappy    _       =  False\n```\n\nWith the same process, complex algebraic data types can be used as patterns as well.\n\n```\n// Language: Clean\n\n:: Tree = Branch Tree Tree\n        | Leaf\n\nisBranch :: Tree           -\u003e Bool\nisBranch    (Branch l r)   =  True\nisBranch    _              =  False\n\n:: TreeInfix = (/\\) TreeInfix TreeInfix\n               | Leaf\n\nisBranchInfix :: TreeInfix -\u003e Bool\nisBranchInfix   (l/\\r)     =  True\nisBranchInfix   _          =  False\n```\n\n### Record Types\n\nA record type is an algebraic data type in which exactly one constructor is defined.\nA field name is attached to each of the arguments of the constructor.\n\n#### Defining A Record Type\n\nA record type is a tuple-like algebraic data structure that has the advantage that its elements can be selected by field name rather than by position.\n\nA simple record type can be defined as follows.\n\n```\n// Language: Clean\n\n:: [tName] = { [fieldName] :: [fieldType] }\n```\n\nFields must be separated commas ($,$).\n\n```\n// Language: Clean\n\n:: [tName] = { [fNameA] :: [fTypeA] , [fNameB] :: [fTypeB] , [fNameC] :: [fTypeC]  }\n```\n\nTo increase readability, fields can be placed on different lines.\n\n```\n// Language: Clean\n\n:: [tName] = { [fNameA] :: [fTypeA]\n             , [fNameB] :: [fTypeB]\n             , [fNameC] :: [fTypeC]\n             }\n```\n\nFor example, a record type for representing complex numbers can be defined as follows.\n\n```\n// Language: Clean\n\n:: Complex = { re :: Real\n             , im :: Real\n             }\n```\n\n#### Creating Objects Of Record Types\n\nThe field names are case-sensitive, but the field order does not matter.\nEvery field of a record type must be given.\n\n```\n// Language\n\n:: Complex = { re :: Real\n             , im :: Real\n             }\n\nA :: Complex\nA =  { re = 1.0 , im = 0.0 }\n\nB :: Complex\nB =  { im = 1.0 , re = 0.0}\n```\n\nThe name of a record type can be added to the constructor.\nIn such a case, the type annotation can be omitted.\n\n```\n// Language: Clean\n\n:: Point = { x :: Int\n           , y :: Int\n           }\n\n:: Position = { x :: Int\n              , y :: Int\n              }\n\n// A :: Point\n// A =  { x = 0 , y = 0 }\nA =  { Point | x = 0 , y = 0 }\n\n// B :: Position\n// B =  { x = 0 , y = 0 }\nB =  { Position | x = 0 , y = 0 }\n```\n\n**Record update**\n\nA new record object can be constructed from an existing one.\n\n```\n// Language: Clean\n\n{ [oldObject] \u0026 [fName] = [newValue] }\n```\n\nMultiple fields can be updated all at once.\n\n```\n// Language: Clean\n\n{ [oldObject] \u0026 [fNameA] = [newValueA] , [fNameB] = [newValueB] }\n```\n\nFor example:\n\n```\n// Language: Clean\n\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nA :: PosThree\nA =  { x = 0 , y = 0 , z = 0 }  // (PosThree 0 0 0)\n\nB :: PosThree\nB =  { A \u0026 x = 1 , y = 1 }      // (PosThree 1 1 0)\n```\n\n#### Record Type Patterns\n\nAn object of type record can be specified as pattern.\nNot every field must be used.\n\n```\n// Language: Clean\n\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nisZeroX :: PosThree -\u003e Bool\nisZeroX    { x=0 }  =  True\nisZeroX    _        =  False\n\nA :: PosThree\nA =  { x = 0 , y = 0 , z = 0 }\n\nisZeroX A  // True\n\nB :: PosThree\nB =  { A \u0026 x = 1 , y = 1 }\n\nisZeroX B  // False\n```\n\nAlternatively, record fields can be extracted without patterns.\n\n```\n// Language: Clean\n\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nisZeroY :: PosThree -\u003e Bool\nisZeroY    { y=r }    =  r == 0\n```\n\nIn the implementation above, the record field $y$ is extracted to $r$.\nIt can be used referred by the body.\n\nRecord fields can be extracted to an identifier of the same name.\n\n```\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nisZeroZ :: PosThree -\u003e Bool\nisZeroZ    { z }    =  z == 0\n```\n\nThe implementation above is equivalent to the following:\n\n```\n// Language: Clean\n\nisZeroZ :: PosThree -\u003e Bool\nisZeroZ    { z=z }  =  z == 0\n```\n\n**Record field selection**\n\nThe value of a record field can be selected using dot operator ($.$).\n\n```\n// Language: Clean\n\n[recordObj].[fName]\n```\n\nFor example, a simple getter function on $\\textbf{Point}$ can be defined as follows.\n\n```\n:: Point = { x :: Int\n           , y :: Int\n           }\n\ngetX :: Point -\u003e Int\ngetX    p     =  p.x\n\nA :: Point\nA =  { x = 1 , y = 0 }\n\ngetX a  // 1\n```\n\n### Synonym Types\n\nSynonym types allow for an introduction of a new type name for an existing type.\n\n#### Defining A Synonym Type\n\nA simple synonym type has the follow syntax:\n\n```\n// Language: Clean\n\n:: [tName] :== [existingType]\n```\n\nFor example, an array of characters can be viewed as a string.\n\n```\n// Language: Clean\n\n:: String :== {Char}\n```\n\nSynonym types also accept generic types as arguments.\n\n```\n// Language: Clean\n\n:: [tName] T K :== [existingType] T K\n```\n\nFor example, an arity-two operator can be shortened with a synonym type.\n\n```\n// Language: Clean\n\n:: Op T :== T T -\u003e T\n\n// add :: Int Int -\u003e Int\nadd :: (Op Int)\n```\n\n---\n\n## Overloading\n\n### Overloaded Functions\n\nFunctions and operators are defined on built-in types.\nHowever, when interacting with custom data types, they do not have any defined function or operator.\n\nThat is, adding two objects of $\\textbf{Complex}$ type is not allowed.\n\n```\n// Language: Clean\n\n:: Complex = { re :: Real\n             , im :: Real\n             }\n\na :: Complex\na =  { re = 0.0 , im = 1.0 }\n\nb :: Complex\nb =  { re = 0.0 , im = 1.0 }\n\na + b  // NOT OK :(\n```\n\nThis happens because addition is not defined on $\\textbf{Complex}$ type.\n\nIn this case, addition can be overloaded on $\\textbf{Complex}$ type.\n\n```\n// Language: Clean\n\ninstance + Complex\nwhere\n    (+) x y = { Complex | re=(x.re + y.re) , im=(x.im + y.im)}\n\na + b  // (Complex 0.0 2.0)\n```\n\nOnly after overloading the addition operation on $\\textbf{Complex}$ that the addition is allowed.\nIn other word, the complier now knows the meaning of complex number addition.\n\nA list of functions and operations which can be overloaded can be found on [Appendix A: StdOverloaded](appendix-a/stdoverloaded).\n\n#### Defining An Overloaded Function Or Operator\n\nTo overload the built-in functions and operations, the general syntax is as follows.\n\n```\n// Language: Clean\n\ninstance [clsName] [typeVars]\nwhere\n    [fnImplementation]\n    [opImplementation]\n```\n\nFunctions and operators can be defined in terms of existing overloaded functions.\nThis is especially useful when dealing with generic types.\n\n```\n// Language: Clean\n\nincrement :: T -\u003e T\nincrement    x =  x + 1\n```\n\nIt is adding an object of type $\\textbf{T}$ and $1$ which is an integer.\nUnless the addition is instantiated for mentioned types, this implementation would not work as intended.\n\nOne way to ensure that it works for all type is to introduce class context.\n\n```\nincrement :: T -\u003e T | + T \u0026 one T\nincrement    x =  x + one\n```\n\nThe new implementation requires that the addition operation, as well as, $\\textbf{one}$ unit is defined on a generic type $\\textbf{T}$.\n\nIn this case, the function is defined in terms of an overloaded function and a unit.\n\nSuch declaration has the following syntax.\n\n```\n// Language: Clean\n\n[fnName] :: [typeVars] -\u003e [typeVar] | [clsConstraints]\n```\n\nClass constraints are separated by ampersands ($\\\u0026$).\n\n### Classes\n\nA class gives name to a group of overloaded functions and operators.\nThese functions and operators are members of the class.\n\n```\n// Language: Clean\n\nclass Equal T\nwhere\n    (==) infixl 4 :: T T -\u003e Bool\n    (\u003c\u003e) infixl 4 :: T T -\u003e Bool\n```\n\nThe class $\\text{Eq}$ has two members.\nThey are equality and inequality operators.\n\nTo instantiate a class, all of its members must be implemented.\n\n```\n// Language: Clean\n\ninstance Equal Complex\nwhere\n    (==) x y = (x.re == y.re) \u0026\u0026 (x.im == y.im)\n    (\u003c\u003e) x y = (x.re \u003c\u003e y.re) || (x.im \u003c\u003e y.im))\n```\n\nA list of classes can be found on [Appendix A: StdClass](appendix-a/stdclass).\n\n#### Defining A Class\n\nAs shown above, a class simple provides a name to collection of logically-linked functions and operations.\n\nIt can be defined with the following syntax.\n\n```\n// Language: Clean\n\nclass [clsName] [typeVars]\nwhere\n    [fnDeclaration]\n    [opDeclaration]\n```\n\nType variables declared can be referred to by all of its member, but they must be given as arguments when the class is instantiated.\n\n```\n// Language: Clean\n\nclass MinMaxC T K\nwhere\n    minC :: T T -\u003e K\n    maxC :: T T -\u003e K\n\ninstance MinMax Real Int\nwhere\n    minC x y = toInt (min x y)\n    maxC x y = toInt (max x y)\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/Constants":{"title":"","content":"There are two distinct types of constants; constant expressions and constant functions.\n\n#### Constant Expressions\n\nThey are computed only once.\nMultiple reference to the same expression will result in sharing of that expression.\n\nA control constant expression may be written as follows\n\n```\n// Language: Clean\n\nconstExprName = expression\n```\n\nIn global scope, a constant expression may be explicitly defined with `=:` symbol.\n\n```\n// Language: Clean\n\n// In global scope\n\nconstExprName =: expression\n```\n\n#### Constant Functions\n\nThey are arity-zero functions.\nUnlike constant expressions, they are re-computed every they invoked.\n\nA control constant function may be written as follows.\n\n```\n// Language: Clean\n\nconstFnName = expression\n```\n\nIn global scope, a constant function may be explicitly defined with right double arrow (`=\u003e`).\n\n```\n// Language: Clean\n\n// In global scope\n\nconstFnName =\u003e expression\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/Expressions/Case-Expressions":{"title":"","content":"A `case..of..` expression matches a given expression with one of its patterns, and a control expression with one pattern may be written as follows.\n\n```\n// Language: Clean\n\ncase expression of\npattern = altExpression\n```\n\nAlternatively, right double arrow (`=\u003e`) and right arrow (`-\u003e`) may be used to separated a pattern from an alternative expression, but they are not allowed to mix.\n\n```\n// Language: Clean\n\ncase expression of\npattern =\u003e altExpression\n\ncase expression of\npattern -\u003e altExpression\n```\n\nMultiple patterns and alternative expressions can be introduced in the same way.\n\n```\n// Language: Clean\n\ncase expression of\npatternA = altExpressionA\npatternB = altExpressionB\npatternC = altExpressionC\n```\n\nGuarded expressions can be introduced as well, which allows a case to have multiple guarded bodies.\n\n```\n// Language: Clean\n\ncase expression of\npatternA\n| guardA = altExpressionAA\n| guardB = altExpressionAB\n| guardC = altExpressionAC\n```\n\nInternally, a `case..of..` expression is compiled to a function.\nThat is, each case is transformed into an implementation of a function.\n\n```\n// language: Clean\n\n__compiledExpr patternA = altExpressionA\n__compiledExpr patternB = altExpressionB\n__compiledExpr patternC = altExpressionC\n```\n\nThis explains why guarded expressions can be introduced.\n\n```\n// language: Clean\n\n__compiledExpr patternA\n| guardAA               = altExpressionAA\n| guardAB               = altExpressionAB\n| guardAC               = altExpressionAC\n```\n\nConsequently, such an expression can result in a run-time error since it is translated into a partial function.","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/Expressions/Lambda-Expressions":{"title":"","content":"### Lambda Functions\n\nA control lambda function may be written as follows.\n\n```\n// Language: Clean\n\n\\ parameter = expression\n```\n\nAlternatively, dot (`.`) and right arrow (`-\u003e`) may be used to separate  parameters from expression.\nIt should be noted that they have different semantic meanings.\n\n```\n// Language: Clean\n\n\\ parameter .  expression\n\\ parameter -\u003e expression\n```\n\nParameters of a lambda function are space separated.\n\n```\n// Language: Clean\n\n\\ paramA paramB = expression\n```\n\nGuarded expressions can be introduced as well.\n\n```\n// Language: Clean\n\n\\ parameter | guardA = expressionA | guardB = expressionB | guardC = expressionC\n```\n\nTo increase readability, a lambda definition maybe placed between a pair of parentheses, which allows it to span multiple lines.\n\n```\n// Language: Clean\n\n(\\ parameter \n| guardA = expressionA \n| guardB = expressionB \n| guardC = expressionC)\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/Expressions/Pattern-Match-Expressions":{"title":"","content":"A pattern-match expression checks an expression against a pattern, and a control expression may be written as follows.\n\n```\n// Language: Clean\n\nexpression =: pattern\n```\n\nIf a given expression matches with the pattern, it yields `true`.\n\nInternally, it is compiled down to a `case..of..` expression.\n\n```\n// Language: Clean\n\ncase expression of\npattern = True\n_       = False\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/Expressions/Special-Expressions":{"title":"Special Expressions","content":"","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/Local-Scopes":{"title":"","content":"#### Let Expressions\n\nA `let..in..` expression introduces a new scope within another expression.\n\nA control expression with one local definition may be written as follows.\n\n```\n// Language: Clean\n\nlet\n    localFunction x = ...\nin expression\n```\n\nDefinitions are local to `expression`.\n\n```\n// Language: Clean\n\n[letÂ \n    aÂ =Â i * iÂ \ninÂ (a,Â a)Â \\\\Â iÂ \u003c-Â [0..n]]\n```\n\n#### Where Blocks\n\nA `where` block can be introduced to the end of a function implementation.\nIt introduces a new scope local to that implementation.\n\nA control `where` block with one definition may be written as follows.\n\n```\n// Language: Clean\n\nfunctionA parameter = expression\nwhere\n    localFunc x = ...\nfunctionA parameter = expression\n```\n\nThe second implementation does not have access to `localFunc` which is local to the first implementation.\n\n#### With Blocks\n\nA `with` block can be introduced to the end of a guarded.\nIt introduces a new scope local to that guarded expression.\n\nA control `with` block with one definition may be written as follows.\n\n```\n// Language: Clean\n\nfunctionA parameter\n| guardA = expressionA\nwith \n    localFunc x = ...\n| guardB = expressionB\n```\n\nHowever, the guard itself does not have access to definitions within its `with` block.\n\n```\n// Language: Clean\n\nfunctionA n\n| x == 0    = 0\nwith \n    x = n mod 2\n| otherwise = 1\n```\n\nThe definition of `functionA` is not valid since the guard cannot reference `x`.","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/introduction":{"title":"Appendix A: Standard Environment","content":"\n## Introduction\n\nThis section is referred to by other parts of the reference to increase readability and clarity.\nIt is a summary of the Standard Environment provided by creators of CLEAN.\nSome functions which can be easily synthesized from other functions are omitted.\n\nThe Standard Environment includes, but not limited to, the following modules.\n\n| Module                                       | Description                                                       |\n| -------------------------------------------- | ----------------------------------------------------------------- |\n| [StdArray](appendix-a/stdarray.md)           | Operations and functions on arrays                                |\n| [StdBool](appendix-a/stdbool.md)             | Logical operations                                                |\n| [StdChar](appendix-a/stdchar.md)             | Operations and functions on characters                            |\n| [StdCharList](appendix-a/stdcharlist.md)     | Operations and functions on lists, whose elements are characters  |\n| [StdClass](appendix-a/stdclass.md)           | Predefined classes                                                |\n| [StdInt](appendix-a/stdint.md)               | Operations and functions on integers                              |\n| [StdList](appendix-a/stdlist.md)             | Operations and functions on lists                                 |\n| [StdMisc](appendix-a/StdMisc.md)             | Miscellaneous functions                                           |\n| [StdOrdList](appendix-a/stdordlist.md)       | Operations and functions on lists, whose element can be ordered   |\n| [StdOverloaded](appendix-a/stdoverloaded.md) | Predefined overloaded operations and functions                    |\n| [StdReal](appendix-a/stdreal.md)             | Operations and functions on real numbers                          |\n| [StdString](appendix-a/stdstring.md)         | Operations and functions on arrays, whose elements are characters |\n| [StdTuple](appendix-a/stdtuple.md)           | Operations and functions on tuples                                |","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdarray":{"title":"Appendix A: StdArray","content":"\n## Basic Operations\n\n### Indexing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ is of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns element at $i$-th index of $A$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n\"abcde\".[5]     // NOT OK :(\n\"abcde\".[2]     // 'c'\n\"abcde\".[0]     // 'a'\n\"abcde\".[(-1)]  // NOT OK :(\n```\n\n### Update At\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ and $R$ are of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $a$ is of type $\\textbf{T}$.\n\n**Behavior**: updates element at $i$-th index of $A$ with $a$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n{\"abcde\" \u0026 [5] = 'X'}     // NOT OK :(\n{\"abcde\" \u0026 [2] = 'C'}     // \"abCde\"\n{\"abcde\" \u0026 [0] = 'A'}     // \"Abcde\"\n{\"abcde\" \u0026 [(-1)] = 'X'}  // NOT OK :(\n\n{\"abcde\" \u0026 [0] = 'A', [1] = 'B'}\n// \"ABcde\"\n```\n\n---\n\n## Basic Functions\n\n### `select`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $R$ are of type $\\textbf{T}$.\n\n**Behavior**: returns the $i$-th element of $A$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n\n```\n// Language: Clean\n \nselect \"abcde\" 5     // NOT OK :(\nselect \"abcde\" 2     // 'c'\nselect \"abcde\" 0     // 'a'\nselect \"abcde\" (-1)  // NOT OK :(\n```\n\n### `size`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $\\{\\textbf{T}\\}$,\n- $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns size of $A$.\n\n**Usage**\n\n\n```\n// Language: Clean\n \nsize \"abcde\"  // 5\nsize \"abcd\"   // 4\nsize \"abc\"    // 3\nsize \"ab\"     // 2\n```\n\n### `update`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ and $R$ are of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $a$ is of type $\\textbf{T}$.\n\n**Behavior**: updates element at $i$-th index of $A$ with $a$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n```\n// Language: Clean\n \nupdate \"abcde\"   5  'X'  // NOT OK :(\nupdate \"abcde\"   2  'C'  // \"abCde\"\nupdate \"abcde\"   0  'A'  // \"Abcde\"\nupdate \"abcde\" (-1) 'X'  // NOT OK :(\n```\n\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdbool":{"title":"Appendix A: StdBool","content":"\n## Introduction\n\nThe [StdBool](https://cloogle.org/src/#base-stdenv/StdBool;icl;line=1) module contains implementation for logical operations.\n\nWhen imported, this module allows for:\n- evaluation of Boolean expressions, and\n- conversion from Boolean type.\n\n---\n\n## Logical Operations\n\n### Logical EQUIVALENCE\n\n**Signature**\n\n```\n// Language: Clean\n\n(==) infix 4 :: Bool Bool -\u003e Bool\n(==)            a    b    =\u003e ...\n```\n\n**Behavior**: returns true if both `a` and `b` have the same logical value.\n\n**Usage**\n\n```\n// Language: Clean\n\nTrue  == True   // True\nTrue  == False  // False\nFalse == True   // False\nFalse == False  // True\n```\n\n### Logical OR\n\n**Signature**\n\n```\n// Language: Clean\n\n(||) infixr 2 :: Bool Bool -\u003e Bool\n(||)             a    b    =\u003e ...\n```\n\n**Behavior**: returns true if  `a` or `b` is true.\n\n**Usage**\n\n```\n// Language: Clean\n\nTrue  || True   // True\nTrue  || False  // True\nFalse || True   // True\nFalse || False  // False\n```\n\n### Logical AND\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u0026\u0026) infixr 3 :: Bool Bool -\u003e Bool\n(\u0026\u0026)             a    b    =\u003e ...\n```\n\n**Behavior**: returns true if `a`and `b` are true.\n\n**Usage**\n\n```\n// Language: Clean\n\nTrue  \u0026\u0026 True   // True\nTrue  \u0026\u0026 False  // False\nFalse \u0026\u0026 True   // False\nFalse \u0026\u0026 False  // False\n```\n\n---\n\n## Logical Functions\n\n### Logical NEGATE\n\n**Signature**\n\n```\n// Language: Clean\n\nnot :: Bool -\u003e Bool\nnot    a    =\u003e ...\n```\n\n**Behavior**: negates the logical value of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nnot True        // False\nnot False       // True\nnot (not True)  // True\n```\n\n---\n\n## Conversions From Boolean Type\n\nExplicitly converts Boolean type to other types.\nThe desired type must be unambiguous.\n\n### To String type\n\n**Signature**\n\n```\nfromBool :: Bool -\u003e {#Char}\nfromBool    a    =\u003e ...\n```\n\n**Behavior**: returns a string representation of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: {#Char}\nexpr =  fromBool True   // \"True\"\nexpr =  fromBool False  // \"False\"\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdchar":{"title":"Appendix A: StdChar","content":"\n## Introduction\n\nThe [StdChar](https://cloogle.org/src/#base-stdenv/StdChar;icl;line=1) module contains implementation for operations and functions relating to integer type.\n\nWhen imported, this module allows for:\n- addition and subtraction between two characters,\n- comparison between two characters,\n- character manipulation,\n- property testing, and\n- conversion to and from character type.\n\n## Constants\n\n### Zero Unit\n\n**Implementation**\n\n```\n// Language: Clean\n\nzero ::  Char\nzero :== (toChar 0)\n```\n\n**Definition**: represents a character with ASCII value of zero.\n\n### One Unit\n\n**Implementation**\n\n```\n// Language: Clean\n\none ::  Char\none :== (toChar 1)\n```\n\n**Definition**: represents a character with ASCII value of one.\n\n---\n\n## Arithmetic Operations\n\nTwo arithmetic operations are available on character type.\nThey are rarely used due to their implementations.\n\n### Addition\n\n**Signature**\n\n```\n// Language: Clean\n\n(+) infixl 6 :: Char Char -\u003e Char\n(+)             a    b    =\u003e ...\n```\n\n**Behavior**: converts `a` and `b` to integers based on their ASCII values.\nThe result of their addition is converted back to a character.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' + '1'  // 49 + 49 -\u003e  98 ('b')\n'A' + 'A'  // 65 + 65 -\u003e 130 ('Ã©')\n'a' + 'a'  // 97 + 97 -\u003e 194 ('â”¬')\n```\n\n### Subtraction\n\n**Signature**\n\n```\n// Language: Clean\n\n(-) infixl 6 :: Char Char -\u003e Char\n(-)             a    b    =\u003e ...\n```\n\n**Behavior**: converts `a` and `b` to integers based on their ASCII values. \nThe result of their subtraction is converted back to a character.\n\n**Usage**\n\n```\n// Language: Clean\n\n'z' - '0'  // 122 - 48 -\u003e 74 ('J')\n'z' - '1'  // 122 - 49 -\u003e 73 ('I')\n'z' - '2'  //  97 + 50 -\u003e 72 ('H')\n```\n\n---\n\n## Relational Operations\n\nAll six relation operations are available on character type.\nThey are implemented with the same behavior.\nThat is, they compare two characters based on their ASCII values.\n\n### Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(==) infix 4 :: Char Char -\u003e Bool\n(==)            a    b    =\u003e ...\n```\n\n**Behavior**: returns true if ASCII value of `a` is equal to ASCII value of `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' == 'A'  // False\n'a' == '1'  // False\n'A' == 'a'  // False\n'1' == '1'  // True\n```\n\n### Not Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c\u003e) infix 4 :: Char Char -\u003e Bool\n(\u003c\u003e)            a    b    =\u003e ...\n```\n\n**Behavior**: returns true if ASCII value of `a` is not equal to ASCII value of `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003c\u003e 'A'  // True\n'a' \u003c\u003e '1'  // True\n'A' \u003c\u003e 'a'  // True\n'1' \u003c\u003e '1'  // False\n```\n\n### Less Than\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c) infix 4 :: Char Char -\u003e Bool\n(\u003c)            a    b    =\u003e ...\n```\n\n**Behavior**: returns true if ASCII value of `a` is strictly less than ASCII value of `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003c 'A'  // True\n'a' \u003c '1'  // False\n'A' \u003c 'a'  // True\n'1' \u003c '1'  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c=) infix 4 :: Char Char -\u003e Bool\n(\u003c=)            a    b    =\u003e ...\n```\n\n**Behavior**: returns true if ASCII value of `a` is less than or equal to ASCII value of `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003c= 'A'  // True\n'a' \u003c= '1'  // False\n'A' \u003c= 'a'  // True\n'1' \u003c= '1'  // True\n```\n\n### Greater Than\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003e) infix 4 :: Char Char -\u003e Bool\n(\u003e)            a    b    =\u003e ...\n```\n\n**Behavior**: returns true if ASCII value of `a` is strictly greater than ASCII value of `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003e 'A'  // False\n'a' \u003e '1'  // True\n'A' \u003e 'a'  // False\n'1' \u003e '1'  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003e=) infix 4 :: Char Char -\u003e Bool\n(\u003e=)            a    b    =\u003e ...\n```\n\n**Behavior**: returns true if ASCII value of `a` is greater than or equal to ASCII value of `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003e= 'A'  // False\n'a' \u003e= '1'  // True\n'A' \u003e= 'a'  // False\n'1' \u003e= '1'  // True\n```\n\n---\n\n## Manipulation Functions\n\nThis group of functions, as its name suggests, manipulate a character.\n\nOne function is left out which is `digitToInt`.\nIts implementation can be found [here](https://cloogle.org/src/#base-stdenv/StdChar;icl;line=115).\n\n### `toUpper`\n\n**Signature**\n\n```\n// Language: Clean\n\ntoUpper :: Char -\u003e Char\ntoUpper    a    =\u003e ...\n```\n\n**Behavior**: returns upper case of `a`.\nIf it is not possible, `a` itself is returned instead.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoUpper '1'  // '1'\ntoUpper 'a'  // 'A'\ntoUpper 'A'  // 'A'\ntoUpper '-'  // '-'\n```\n\n### `toLower`\n\n**Signature**\n\n```\n// Language: Clean\n\ntoLower :: Char -\u003e Char\ntoLower    a    =\u003e ...\n```\n\n**Behavior**: returns lower case of `a`.\nIf it is not possible, `a` itself is returned instead.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoLower '1'  // '1'\ntoLower 'a'  // 'a'\ntoLower 'A'  // 'a'\ntoLower '-'  // '-'\n```\n\n---\n\n## Property Functions\n\n### `isUpper`\n\n**Signature**\n\n```\n// Language: Clean\n\nisUpper :: Char -\u003e Bool\nisUpper    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is an upper case character.\n\n**Usage**\n\n```\n// Language: Clean\n\nisUpper '1'  // False\nisUpper 'a'  // False\nisUpepr 'A'  // True\nisUpper '-'  // False\n```\n\n### `isLower`\n\n**Signature**\n\n```\n// Language: Clean\n\nisLower :: Char -\u003e Bool\nisLower    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is a lower case character.\n\n**Usage**\n\n```\n// Language: Clean\n\nisLower '1'  // False\nisLower 'a'  // True\nisLower 'A'  // False\nisLower '-'  // False\n```\n\n### `isAlphanum`\n\n**Signature**\n\n```\n// Language: Clean\n\nisAlphanum :: Char -\u003e Bool\nisAlphanum    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is an alphanumeric character.\n\n**Usage**\n\n```\n// Language: Clean\n\nisAlphanum '1'  // True\nisAlphanum 'a'  // True\nisAlphanum 'A'  // True\nisAlphanum '-'  // False\n```\n\n### `isAlpha`\n\n**Signature**\n\n```\n// Language: Clean\n\nisAlpha :: Char -\u003e Bool\nisAlpha    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is an alphabetic character.\n\n**Usage**\n\n```\n// Language: Clean\n\nisAlpha '1'  // False\nisAlpha 'a'  // True\nisAlpha 'A'  // True\nisAlpha '-'  // False\n```\n\n### `isDigit`\n\n**Signature**\n\n```\n// Language: Clean\n\nisDigit :: Char -\u003e Bool\nisDigit    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is a decimal digit.\n\n**Usage**\n\n```\n// Language: Clean\n\nisDigit '1'  // True\nisDigit 'a'  // False\nisDigit 'A'  // False\nisDigit '-'  // False\n```\n\n### `isOctDigit`\n\n**Signature**\n\n```\n// Language: Clean\n\nisOctDigit :: Char -\u003e Bool\nisOctDigit    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is an octal digit.\n\n**Usage**\n\n```\n// Language: Clean\n\nisOctDigit '1'  // True\nisOctDigit '8'  // False\nisOctDigit 'a'  // False\nisOctDigit 'A'  // False\nisOctDigit '-'  // False\n```\n\n### `isHexDigit`\n\n**Signature**\n\n```\n// Language: Clean\n\nisHexDigit :: Char -\u003e Bool\nisHexDigit    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is a hexadecimal digit.\n\n**Usage**\n\n```\n// Language: Clean\n\nisHexDigit '1'  // True\nisHexDigit 'G'  // False\nisHexDigit 'a'  // True\nisHexDigit 'A'  // True\nisHexDigit '-'  // False\n```\n\n### `isAscii`\n\n**Signature**\n\n```\n// Language: Clean\n\nisAscii :: Char -\u003e Bool\nisAscii    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is an [7-bit ASCII character](https://en.wikipedia.org/wiki/ASCII).\n\n**Usage**\n\n```\n// Language: Clean\n\nisAscii '1'  // True\nisAscii 'a'  // True\nisAscii 'A'  // True\nisAscii '-'  // True\nisAscii 'Ã‡'  // False\n```\n\n### `isControl`\n\n**Signature**\n\n```\n// Language: Clean\n\nisControl :: Char -\u003e Bool\nisControl    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is a [control character](https://en.wikipedia.org/wiki/ASCII#Control_characters).\n\n**Usage**\n\n```\n// Language: Clean\n\nisControl '1'   // False\nisControl 'a'   // False\nisControl 'A'   // False\nisControl '-'   // False\nisControl '\\t'  // True\n```\n\n### `isPrint`\n\n**Signature**\n\n```\n// Language: Clean\n\nisControl :: Char -\u003e Bool\nisControl    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is a [printable character](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n\n**Usage**\n\n```\n// Language: Clean\n\nisPrint '1'  // True\nisPrint 'a'  // True\nisPrint 'A'  // True\nisPrint '-'  // True\nisPrint '\\t' // False\n```\n\n### `isSpace`\n\n**Signature**\n\n```\n// Language: Clean\n\nisSpace :: Char -\u003e Bool\nisSpace    a    =\u003e ...\n```\n\n**Behavior**: returns true if `a` is a space character.\nSpace characters are defined as follows:\n\n| Glyph  | Name            |\n| ------ | --------------- |\n| `' '`  | Space           |\n| `'\\t'` | Horizontal tab  |\n| `'\\v'` | Vertical tab    |\n| `'\\n'` | Line feed       |\n| `'\\r'` | Carriage return |\n| `'\\f'` | Form feed       |\n\n**Usage**\n\n```\n// Language: Clean\n\nisSpace '1'   // False\nisSpace 'a'   // False\nisSpace 'A'   // False\nisSpace '-'   // False\nisSpace '\\t'  // True\n```\n\n---\n\n## Conversions To Character Type\n\nExplicitly converts other types to character type.\n\n### From Integer Type\n\n**Signature**\n\n```\ntoChar :: Int -\u003e Char\ntoChar    a   =\u003e ...\n```\n\n**Behavior**: returns an ASCII character whose value is `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoChar 49  // '1'\ntoChar 65  // 'A'\ntoChar 97  // 'a'\n```\n\n---\n\n## Conversions From Character Type\n\nExplicitly converts character type to other types.\nThe desired type must be unambiguous.\n\n### To Integer Type\n\n**Signature**\n\n```\nfromChar :: Char -\u003e Int\nfromChar    a    =\u003e  ...\n```\n\n**Behavior**: returns ASCII value of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: Int\nexpr =  fromChar '1'  // 49\nexpr =  fromChar 'A'  // 65\nexpr =  fromChar 'a'  // 97\n```\n\n### To String Type\n\n**Signature**\n\n```\n// Language: Clean\n\nfromChar :: Char -\u003e {#Char}\nfromChar    a    =\u003e ...\n```\n\n**Behavior**: returns a one-character string containing `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: {#Char}\nexpr =  fromChar '1'  // \"1\"\nexpr =  fromChar 'A'  // \"A\"\nexpr =  fromChar 'a'  // \"a\"\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdcharlist":{"title":"Appendix A: StdCharList","content":" \n## Basic Functions\n\n### `cjustify`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: center-aligns $A$ with left and right spaces.\n\n**Usage**\n\n```\n// Language: Clean\n\ncjustify 5 ['a', 'b', 'c']  // [' ', 'a', 'b', 'c', ' ']\ncjustify 5 ['a', 'b']       // [' ', 'a', 'b', ' ', ' ']\ncjustify 3 ['a', 'b']       // ['a', 'b', ' ']\ncjustify 3 ['a']            // [' ', 'a', ' ']\ncjustify 1 ['a', 'b']       // ['a', 'b']\n```\n\n### `ljustify`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: left-aligns $A$ with spaces.\n\n**Usage**\n\n```\n// Language: Clean\n\nljustify 5 ['a', 'b', 'c']  // ['a', 'b', 'c', ' ', ' ']\nljustify 5 ['a', 'b']       // ['a', 'b', ' ', ' ', ' ']\nljustify 3 ['a', 'b']       // ['a', 'b', ' ']\nljustify 3 ['a']            // ['a', ' ', ' ']\nljustify 1 ['a', 'b']       // ['a', 'b']\n```\n\n### `rjustify`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: right-aligns $A$ with spaces.\n\n**Usage**\n\n```\n// Language: Clean\n\nrjustify 5 ['a', 'b', 'c']  // [' ', ' ', 'a', 'b', 'c']\nrjustify 5 ['a', 'b']       // [' ', ' ', 'a', 'b']\nrjustify 3 ['a', 'b']       // [' ', 'a', 'b']\nrjustify 3 ['a']            // [' ', ' ', 'a']\nrjustify 1 ['a', 'b']       // ['a', 'b']\n```\n\n### `flatlines`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: joins elements of $A$ with newline characters.\n\n**Usage**\n\n```\n// Language: Clean\n\nflatlines [['a'], ['b']]  // ['a', '\\n', 'b', '\\n']\nflatlines ['a']           // ['a', '\\n']\nflatlines []              // []\n```\n\n### `mklines`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$,\n- $A$ is of type $[\\textbf{Char}]$, and\n- $R$ is of type $[[\\textbf{Char}]]$.\n\n**Behavior**: splits $A$ at newline characters.\n\n**Usage**\n\n```\n// Language: Clean\n\nmklines ['a', '\\n', 'b', '\\n']  // [['a'], ['b']]\nmklines ['a', '\\n']             // [['a']]\nmklines []                      // []\n```\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdclass":{"title":"Appendix A: StdClass","content":"\n## Arithmetic Classes\n\n### `PlusMin`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass PlusMin T | (+ T) \u0026 (- T) \u0026 (zero T)\n```\n\n### `MultDiv`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass MultDiv T | (* T) \u0026 (/ T) \u0026 (one T)\n```\n\n### `Arith`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Arith T | (PlusMin T) \u0026 (MultDiv T) \u0026 (abs T) \u0026 (sign T) \u0026 (~ T)\n```\n\n### `IncDec`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass IncDec T | (+ T) \u0026 (- T) \u0026 (one T) \u0026 (zero T)\nwhere\n    inc :: T -\u003e T\n    inc    x =  x + one\n\n    dec :: T -\u003e T\n    dec    x =  x - one\n```\n\n### `Enum`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Enum T | (\u003c T) \u0026 (IncDec T)\nwhere\n```\n\n---\n\n## Relational Classes\n\n### `Eq`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Eq T | == T\nwhere\n    (\u003c\u003e) infixl 4 :: T T -\u003e Bool\n    (\u003c\u003e)             x y =  not (x == y)\n```\n\n### `Ord`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Ord T | \u003c T\nwhere\n    (\u003c=) infixl 4 :: T T -\u003e Bool\n    (\u003c=)             x y =  not (y \u003c x)\n    \n    (\u003e) infixl 4 :: T T -\u003e Bool\n    (\u003e)             x y =  y \u003c x\n    \n    (\u003e=) infixl 4 :: T T -\u003e Bool\n    (\u003e=)             x y =  not (x \u003c y)\n\n    min :: T T -\u003e T\n    min    x y =  case (x \u003c y) of \n                  True = x\n                  _    = y\n    \n    max :: T T -\u003e T\n    max    x y =  case (x \u003c y) of \n                  True = y\n                  _    = x\n```\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdint":{"title":"Appendix A: StdInt","content":"\n## Introduction\n\nThe [StdInt](https://cloogle.org/src/#base-stdenv/StdInt;icl;line=1) module contains source code for operations and functions relating to integer type.\n\n For integer type, this module implements:\n- arithmetic operations,\n- comparisons,\n- bitwise operations,\n- property testing, and\n- conversions.\n\n## Constants\n\n### Zero Unit\n\n**Implementation**\n\n```\n// Language: Clean\n\nzero ::  Int\nzero :== 0\n```\n\n**Definition**: represents the value zero for integers.\n\n### One Unit\n\n**Implementation**\n\n```\n// Language: Clean\n\none ::  Int\none :== 1\n```\n\n**Definition**: represents the value one for integers.\n\n---\n\n## Arithmetic Operations and Functions\n\n\n### Negation\n\n**Signature**\n\n```\n// Language: Clean\n\n~ :: Int -\u003e Int\n~    a   =\u003e ...\n```\n\n**Behavior**: inverts the sign `a`.\n\n**Usage**\n\n```\n// Language: Clean\n \n~  0   //  0\n~  1   // -1\n~(-1)  //  1\n```\n\n### Addition\n\n**Signature** \n\n```\n// Language: Clean\n \n(+) infixl 6 :: Int Int -\u003e Int\n(+)             a   b   =\u003e ...\n```\n\n**Behavior**: adds `a` and `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  +   1   //  2\n  1  + (-1)  //  0\n(-1) +   1   //  0\n(-1) + (-1)  // -2\n```\n\n### Subtraction\n\n**Signature**\n\n```\n// Language: Clean\n \n(-) infixl 6 :: Int Int -\u003e Int\n(-)             a   b   =\u003e ...\n```\n\n**Behavior**: subtracts `b` from `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  -   1  //  0\n  1  - (-1) //  2\n(-1) -   1  // -2\n(-1) - (-1) //  0\n```\n\n### Multiplication\n\n**Signature**\n\n```\n// Language: Clean\n \n(*) infixl 7 :: Int Int -\u003e Int\n(*)             a   b   =\u003e ...\n```\n\n**Behavior**: multiplies `a` and `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  *   1  //  1\n  1  * (-1) // -1\n(-1) *   1  // -1\n(-1) * (-1) //  1\n```\n\n### Floor Division\n\n**Signature**\n\n```\n// Language: Clean\n\n(/) infixl 7 :: Int Int -\u003e Int\n(/)             a   b   =\u003e ...\n```\n\n**Behavior**: divides `a` by `b`.\nSilently crashes if `b` is zero.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  /   1   //  1\n  1  / (-1)  // -1\n(-1) /   1   // -1\n(-1) / (-1)  //  1\n  7  /   0   //  crashes\n```\n\n### Reminder Division\n\n**Signature**\n\n```\n// Language: Clean\n\n(rem) infix 7 :: Int Int -\u003e Int\n(rem)            a   b   =\u003e ...\n```\n\nand\n\n```\n// Language: Clean\n\n(mod) infix 7 :: Int Int -\u003e Int\n(mod)            a   b   =\u003e ...\n```\n\nFor integers, both `rem` and `mod` perform modulo division.\n\n**Behavior**: divides `a` by `b`, and returns the reminder.\n\n**Usage**\n\n```\n// Language: Clean\n\n  3  mod (-2)  //  1\n(-3) mod (-2)  // -1\n(-3) mod   2   // -1\n  3  mod   2   //  1\n```\n\n### Exponentiation\n\n**Signature**\n\n```\n// Language: Clean\n\n(^) infixr 8 :: Int Int -\u003e Int\n(^)             a   b   =\u003e ...\n```\n\n**Behavior**: raises `a` to `b`-th power.\nResults in a run-time error if `b` is negative.\n\n```\n^ (Int) called with negative power argument\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  ^   1   //  1\n  1  ^ (-1)  //  NOT OK :(\n(-1) ^   1   // -1\n(-1) ^ (-1)  //  NOT OK :(  \n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(==) infix 4 :: Int Int -\u003e Bool\n(==)            a   b   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is equal to `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  ==   2   // False\n(-5) ==   2   // False\n  5  == (-2)  // False\n(-5) == (-2)  // False\n(-2) == (-2)  // True\n```\n\n### Not Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c\u003e) infix 4 :: Int Int -\u003e Bool\n(\u003c\u003e)            a   b   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is not equal to `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c\u003e   2   // True\n(-5) \u003c\u003e   2   // True\n  5  \u003c\u003e (-2)  // True\n(-5) \u003c\u003e (-2)  // True\n(-2) \u003c\u003e (-2)  // False\n```\n\n### Less Than\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c) infix 4 :: Int Int -\u003e Bool\n(\u003c)            a   b   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is strictly less than `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c   2   // False\n(-5) \u003c   2   // True\n  5  \u003c (-2)  // False\n(-5) \u003c (-2)  // True\n(-2) \u003c (-2)  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c=) infix 4 :: Int Int -\u003e Bool\n(\u003c=)            a   b   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is less than or equal to `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c=   2   // False\n(-5) \u003c=   2   // True\n  5  \u003c= (-2)  // False\n(-5) \u003c= (-2)  // True\n(-2) \u003c= (-2)  // True\n```\n\n### Greater Than\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003e) infix 4 :: Int Int -\u003e Bool\n(\u003e)            a   b   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is strictly greater than `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003e   2   // True\n(-5) \u003e   2   // False\n  5  \u003e (-2)  // True\n(-5) \u003e (-2)  // False\n(-2) \u003e (-2)  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003e=) infix 4 :: Int Int -\u003e Bool\n(\u003e=)            a   b   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is greater than or equal to `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003e=   2   // True\n(-5) \u003e=   2   // False\n  5  \u003e= (-2)  // True\n(-5) \u003e= (-2)  // False\n(-2) \u003e= (-2)  // True\n```\n\n---\n\n## Bitwise Operations and Functions\n\nInteracts with integers through their binary representation.\n\n### Bitwise NEGATE\n\n**Signature**\n\n```\n// Language: Clean\n\nbitnot :: Int -\u003e Int\nbitnot    a   =\u003e ...\n```\n\n**Behavior**: returns bit-wise two complement of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nbitnot (-5)  //  -4\nbitnot (-2)  //   1\nbitnot   2   //  -3\nbitnot   5   //  -6\n```\n\n### Bitwise OR\n\n**Signature**\n\n```\n// Language: Clean\n\n(bitor) infixl 6 :: Int Int -\u003e Int\n(bitor)             a   b   =\u003e ...\n```\n\n**Behavior**: returns bit-wise OR of `a` and `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  bitor   2   //  7\n(-5) bitor   2   // -5\n  5  bitor (-2)  // -1\n(-5) bitor (-2)  // -1\n```\n\n### Bitwise AND\n\n**Signature**\n\n\n```\n// Language: Clean\n\n(bitand) infixl 6 :: Int Int -\u003e Int\n(bitand)             a   b   =\u003e ...\n```\n\n**Behavior**: returns bit-wise AND of `a` and `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  bitand   2   //  0\n(-5) bitand   2   //  2\n  5  bitand (-2)  //  4\n(-5) bitand (-2)  // -6\n```\n\n### Bitwise XOR\n\n**Signature**\n\n```\n// Language: Clean\n\n(bitxor) infixl 6 :: Int Int -\u003e Int\n(bitxor)             a   b   =\u003e ...\n```\n\n**Behavior**: returns bit-wise XOR of `a` and `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  bitxor   2   //  7\n(-5) bitxor   2   // -7\n  5  bitxor (-2)  // -5\n(-5) bitxor (-2)  //  5\n```\n\n### Bitwise Left Shift\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c\u003c) infix 7 :: Int Int -\u003e Int\n(\u003c\u003c)            a   b   =\u003e ...\n```\n\n**Behavior**: shifts `a` to the left by `b` bits.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c\u003c   2   //  20\n(-5) \u003c\u003c   2   // -20\n  5  \u003c\u003c (-2)  //  4611686018427387904\n(-5) \u003c\u003c (-2)  // -4611686018427387904\n```\n\n### Bitwise Right Shift\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003e\u003e) infix 7 :: Int Int -\u003e Int\n(\u003e\u003e)            a   b   =\u003e ...\n```\n\n**Behavior**: shifts `a` to the right by `b` bits.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003e\u003e   2   //  1\n(-5) \u003e\u003e   2   // -2\n  5  \u003e\u003e (-2)  //  0\n(-5) \u003e\u003e (-2)  // -1\n```\n\n---\n\n## Basic Functions\n\n### `sign`\n\n**Signature**\n\n```\n// Language: Clean\n\nsign :: Int -\u003e Int\nsign    a   =\u003e ...\n```\n\n**Behavior**: returns the sign of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nsign   1   //  1\nsign   0   //  0\nsign (-1)  // -1\n```\n\n### `abs`\n\n**Signature**\n\n```\n// Language: Clean\n\nabs :: Int -\u003e Int\nabs    a   =\u003e ...\n```\n\n**Behavior**: returns the absolute value of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nabs   1   // 1\nabs   0   // 0\nabs (-1)  // 1\n```\n\n### `gcd`\n\n**Signature**\n\n```\n// Language: Clean\n\ngcd :: Int Int -\u003e Int\ngcd    a   b   =\u003e ...\n```\n\n**Behavior**: returns the greatest common divisor of `a` and `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\ngcd   3    2   // 1\ngcd (-3)   2   // 1\ngcd   3  (-2)  // 1\ngcd (-3) (-2)  // 1\n```\n\n### `lcm`\n\n**Signature**\n\n```\n// Language: Clean\n\nlcm :: Int Int -\u003e Int\nlcm    a   b   =\u003e ...\n```\n\n**Behavior**: returns the least common multiple of `a` and `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\nlcm   3    2   // 6\nlcm (-3)   2   // 6\nlcm   3  (-2)  // 6\nlcm (-3) (-2)  // 6\n```\n\n---\n\n## Property Functions\n\nTests properties of an integer.\n\n### `isEven`\n\n**Signature**\n\n```\n// Language: Clean\n\nisEven :: Int -\u003e Bool\nisEven    a   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is an even integer.\n\n**Usage**\n\n```\n// Language: Clean\n\nisEven  2  // False\nisEven  1  // True\nisEven  0  // True\nisEven -1  // True\nisEven -2  // False\n```\n\n### `isOdd`\n\n**Signature**\n\n```\n// Language: Clean\n\nisOdd :: Int -\u003e Bool\nisOdd    a   =\u003e ...\n```\n\n**Behavior**: returns true if `a` is an odd integer.\n\n**Usage**\n\n```\n// Language: Clean\n\nisOdd  2  // True\nisOdd  1  // False\nisOdd  0  // False\nisOdd -1  // False\nisOdd -2  // True\n```\n\n---\n\n## Conversions To Integer Type\n\nExplicitly converts values of other types to integer type.\n\n### From Real Number Type\n\n**Signature**\n\n```\ntoInt :: Real -\u003e Int\ntoInt    a    =\u003e ...\n```\n\n**Behavior**: rounds `a` to its nearest integer.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoInt   1.5   //  2\ntoInt   1.4   //  1\ntoInt   0.0   //  0\ntoInt (-1.4)  // -1\ntoInt (-1.5)  // -2\n```\n\n### From Character Type\n\n**Signature**\n\n```\n// Language: Clean\n\ntoInt :: Char -\u003e Int\ntoInt    a    =\u003e ...\n```\n\n**Behavior**: returns ASCII value of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoInt '1'  //  49\ntoInt '9'  //  59\ntoInt 'A'  //  65\ntoInt 'Z'  //  90\ntoInt 'a'  //  97\ntoInt 'z'  // 122\n```\n\n### From String Type\n\n**Signature**\n\n```\n// Language: Clean\n\ntoInt :: {#Char} -\u003e Int\ntoInt    a       =\u003e ...\n```\n\n**Behavior**: attempts to parse `a` to an integer.\nReturns zero if unsuccessful.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoInt \"1.0\"   //  0\t\ntoInt \"1\"     //  1\ntoInt \"0\"     //  0\ntoInt \"-1\"    // -1\ntoInt \"-1.0\"  //  0\n```\n\n---\n\n## Conversions From Integer Type\n\nExplicitly converts integer type to other types.\nThe desired type must be unambiguous.\n\n### To Real Number Type\n\n**Signature**\n\n```\n// Language: Clean\n\nfromInt :: Real -\u003e Int\nfromInt    a    =\u003e ...\n```\n\n**Behavior**: converts an integer `a` into a real number.\nThe decimal place is set to zero.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: Real\nexpr =  fromInt  1  // 1.0\nexpr =  fromInt  0  // 0.0\n```\n\n### To Character Type\n\n**Signature**\n\n```\n// Language: Clean\n\nfromInt :: Int -\u003e Char\nfromInt    a   =\u003e ...\n```\n\n**Behavior**: converts an integer `a` in to a character based on its ASCII value.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: Char\nexpr =  fromInt 49   // '1'\nexpr =  fromInt 59   // '9'\nexpr =  fromInt 65   // 'A'\nexpr =  fromInt 90   // 'Z'\nexpr =  fromInt 97   // 'a'\nexpr =  fromInt 122  // 'z'\n```\n\n### To String Type\n\n**Signature**\n\n```\n// Language: Clean\n\nfromInt :: Int -\u003e {#Char}\nfromInt    a   =\u003e ...\n```\n\n**Behavior**: converts an integer `a` into a string.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: {#Char}\nexpr =  fromInt 1  // \"1\"\nexpr =  fromInt 0  // \"0\"\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdlist":{"title":"Appendix A: StdList","content":"\n## Basic Operations \n\n### Concatenation\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$, $B$, and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: appends $B$ to the end of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n \n[1, 2, 3] ++ [4, 5]  // [1, 2, 3, 4, 5]\n[1, 2, 3] ++ [4]     // [1, 2, 3, 4]\n[1, 2, 3] ++ []      // [1, 2, 3]\n```\n\n### Indexing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ is of type $[\\textbf{T}]$,\n- $i$ is of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns element at $i$-th index of $A$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nSubscript error in !!,index too large\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n[1, 2, 3] !!   5   // NOT OK :(\n[1, 2, 3] !!   2   // 3\n[1, 2, 3] !!   0   // 1\n[1, 2, 3] !! (-1)  // NOT OK :(\n```\n\n### Slicing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow(i, j)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A, R$ are of type $[\\textbf{T}]$, and\n- $i, j$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns elements of $A$ which are inside $[i, j]$ interval.\n\n**Usage**\n\n```\n// Language: Clean\n \n[1, 2, 3] % (  2,  4)  // [3]\n[1, 2, 3] % (  0,  2)  // [1, 2, 3]\n[1, 2, 3] % ((-1), 0)  // [1, 2]\n[1, 2, 3] % ((-2), 5)  // [1, 2, 3]\n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     == []      // True\n[1, 2] == [1, 2]  // True\n[1, 2] == [1]     // False\n[1]    == [1, 2]  // False\n[1, 2] == [1, 3]  // False\n[1, 3] == [1, 2]  // False\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is not equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003c\u003e []        // False\n[1, 2] \u003c\u003e [1, 2]    // False\n[1, 2] \u003c\u003e [1]       // True\n[1]    \u003c\u003e [1, 2]    // True\n[1, 2] \u003c\u003e [1, 3]    // True\n[1, 3] \u003c\u003e [1, 2]    // True\n```\n\n###  Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\text{T}$.\n\n**Behavior**: checks if $A$ is less than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003c []      // False\n[1, 2] \u003c [1, 2]  // False\n[1, 2] \u003c [1]     // False\n[1]    \u003c [1, 2]  // True\n[1, 2] \u003c [1, 3]  // True\n[1, 3] \u003c [1, 2]  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\text{T}$.\n\n**Behavior**: checks if $A$ is less than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003c= []     // True\n[1, 2] \u003c= [1, 2] // True\n[1, 2] \u003c= [1]    // False\n[1]    \u003c= [1, 2] // True\n[1, 2] \u003c= [1, 3] // True\n[1, 3] \u003c= [1, 2] // False\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is greater than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003e []      // False\n[1, 2] \u003e [1, 2]  // False\n[1, 2] \u003e [1]     // True\n[1]    \u003e [1, 2]  // False\n[1, 2] \u003e [1, 3]  // False\n[1, 3] \u003e [1, 2]  // True\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is greater than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003e= []      // True\n[1, 2] \u003e= [1, 2]  // True\n[1, 2] \u003e= [1]     // True\n[1]    \u003e= [1, 2]  // False\n[1, 2] \u003e= [1, 3]  // False\n[1, 3] \u003e= [1, 2]  // True\n```\n\n---\n\n## Basic functions\n\n### `length`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: returns number of elements in $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nlength [1, 2, 3]  // 3\nlength [1, 2]     // 2\nlength [1]        // 1\nlength []         // 0\n```\n\n### `flatten`\n\n**Signature** \n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $\\[\\[\\textbf{T}\\]\\]$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: concatenates elements $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nflatten [[1], [2], [3]]  // [1, 2, 3]\nflatten [[1], [2, 3]]    // [1, 2, 3]\nflatten [[1, 2, 3]]      // [1, 2, 3]\nflatten []               // []\n```\n\n### `hd`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the first element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nhd of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nhd [1, 2, 3]  // 1\nhd [1, 2]     // 1\nhd [1]        // 1\nhd []         // NOT OK\n```\n\n### `tl`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns all except the first element of $A$.\nA run-time error will be thrown if $A$ is empty.\n\n```\ntl of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\ntl [1, 2, 3]  // [2, 3]\ntl [1, 2]     // [2]\ntl [1]        // []\ntl []         // NOT OK\n```\n\n### `last`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the last element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nlast of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nlast [1, 2, 3]  // 3\nlast [1, 2]     // 2\nlast [1]        // 1\nlast []         // NOT OK\n```\n\n### `init`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns all except the last element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\ninit of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\ninit [1, 2, 3]  // [1, 2]\ninit [1, 2]     // [1]\ninit [1]        // []\ninit []         // NOT OK\n```\n\n### `take`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns the first $n$ elements of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\ntake 2 [1, 2, 3]  // [1, 2]\ntake 1 [1, 2]     // [1]\ntake 0 [1]        // []\ntake 0 []         // []\n```\n\n### `drop`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns all but the first $n$ elements of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\ndrop 2 [1, 2, 3]  // [3]\ndrop 1 [1, 2]     // [2]\ndrop 1 [1]        // []\ndrop 0 []         // []\n```\n\n### `reverse`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns a reversed copy of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nreverse [1, 2, 3]  // [3, 2, 1]\nreverse [1, 2]     // [2, 1]\nreverse [1]        // [1]\nreverse []         // []\n```\n\n### `insertAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$,\n- $a$ is of type $\\textbf{T}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: inserts $a$ into the $i$-th index of $A$.\nThe previous element is shifted to the right to make room.\n\n**Usage**\n\n```\n// Language: Clean\n\ninsertAt   2  9 [1, 2]  // [1, 2, 9]\ninsertAt   1  9 [1, 2]  // [1, 9, 2]\ninsertAt   0  9 [1, 2]  // [9, 1, 2]\ninsertAt (-1) 9 [1, 2]  // [1, 2, 9]\n```\n\n### `removeAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: removes the element at $i$-th index of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveAt   2  [1, 2]  // [1, 2]\nremoveAt   1  [1, 2]  // [1]\nremoveAt   0  [1, 2]  // [2]\nremoveAt (-1) [1, 2]  // [1,2]\n```\n\n### `updateAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$,\n- $a$ is of type $\\textbf{T}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: replaces the element at $i$-th index of $A$ with $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nupdateAt   2  9 [1, 2]  // [1, 2]\nupdateAt   1  9 [1, 2]  // [1, 9]\nupdateAt   0  9 [1, 2]  // [9, 2]\nupdateAt (-1) 9 [1, 2]  // [1, 2]\n```\n\n### `splitAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $([\\textbf{T}], [\\textbf{T}])$.\n\n**Behavior**: splits $A$ into two at $i$-th index.\nThe element at $i$-th index goes to the second half.\n\n**Usage**\n\n```\n// Language: Clean\n\nsplitAt   2  [1, 2]  // ([1, 2], [])\nsplitAt   1  [1, 2]  // ([1], [2])\nsplitAt   0  [1, 2]  // ([], [1, 2])\nsplitAt (-1) [1, 2]  // ([1, 2], [])\n```\n\n### `indexList`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $[\\textbf{Int}]$.\n\n**Behavior**: generates a list of indexes from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nindexList [3, 2, 1]  // [0, 1, 2]\nindexList [1, 2]     // [0, 1]\nindexList [2]        // [0]\nindexList []         // []\n```\n\n### `repeat`\n\n**Signature**\n\n$$\n\\begin{align*}\n{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{T}$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates an infinite list of the same element $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nrepeat 0     // [0, 0, 0, ...]\nrepeat 1.0   // [1.0, 1.0, 1.0, ...]\nrepeat 'a'   // ['a', 'a', 'a', ...] \nrepeat True  // [True, True, True, ...]\n```\n\n### `repeatn`\n\n**Signature** \n\n$$\n\\begin{align*}\n{n}\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$,\n- $a$ is of type $\\textbf{T}$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates a list of the same element $a$ with length of $n$.\n\n**Usage**\n\n```\n// Language: Clean\n\nrepeatn 0 0     // []\nrepeatn 1 1.0   // [1.0]\nrepeatn 2 'a'   // ['a', 'a'] \nrepeatn 3 True  // [True, True, True]\n```\n\n### `isMember`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $a$ is of type $\\textbf{T}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: checks $a$ is a member of $A$ or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisMember 4 [1, 2, 3]  // False\nisMember 2 [1, 2, 3]  // True\nisMember 1 []         // False\n```\n\n### `isAnyMember`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ and $B$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: returns true if any element of $B$ is also a element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nisAnyMember [1, 2] [1, 2]  // True\nisAnyMember [1, 2] [3, 4]  // False\nisAnyMember [1, 2] []      // False\nisAnyMember [] [1, 2]      // False\n```\n\n### `removeDup`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes duplicate elements from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveDup [1, 2, 2, 3]  // [1, 2, 3]\nremoveDup [1, 2, 3, 4]  // [1, 2, 3, 4]\nremoveDup []            // []\n```\n\n### `removeMember`\n\n**Signature**\n\n$$\n\\begin{align*}\n{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $a$ is of type $\\textbf{T}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes the first occurrence of $a$ from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveMember 4 [1, 2, 2, 3]  // [1, 2, 2, 3]\nremoveMember 2 [1, 2, 2, 3]  // [1, 2, 3]\nremoveMember 1 [1, 2, 2, 3]  // [2, 2, 3]\nremoveMember 0 []            // []\n```\n\n### `removeMembers`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$, $B$, and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes the first occurrences of the elements of $B$ from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveMembers [1, 2, 3] []  // [1, 2, 3]\nremoveMembers [2, 3] [1]    // [2, 3]\nremoveMembers [1, 1] [1]    // [1]\nremoveMembers [] [1, 2]     // []\n```\n\n### `removeIndex`\n\n**Signature**\n\n$$\n\\begin{align*}\n{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $a$ is of type $\\textbf{T}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $(\\textbf{Int}, [\\textbf{T}])$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes the first occurrence of $a$ from $A$ and returns the its index, as well as, the new list.\nResults in a run-time error if $a$ is not a member of $A$.\n\n```\nError in removeIndex: element not found\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveIndex 2 [1, 2, 2, 3]  // (1, [1, 2, 3])\nremoveIndex 1 [1, 2, 2, 3]  // (0, [2, 2, 3])\nremoveIndex 4 [1, 2, 2, 3]  // NOT OK :(\n```\n\n### `sum`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, addition and zero unit must be defined on $\\textbf{T}$.\n\n**Behavior**: returns sum of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsum [1, 2, 3, 4]  // 10\nsum [1, 2, 3]     // 6\nsum [1, 2]        // 3\nsum [1]           // 1\n```\n\n### `prod`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, multiplication and one unit must be defined on $\\textbf{T}$.\n\n**Behavior**: returns product of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nprod [1, 2, 3, 4]  // 24\nprod [1, 2, 3]     // 6\nprod [1, 2]        // 3\nprod [1]           // 1\n```\n\n### `avg`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, addition, zero unit, and division must be defined on $\\textbf{T}$.\n\n**Behavior**: returns average $A$.\nResults in a run-time error if $A$ is empty.\n\n```\navg called with empty list\n```\n\n**Usage**\n\n```\n// Language: Clean\n\navg [1, 2, 3, 4]  // 2\navg [1, 2, 3]     // 2\navg [1, 2]        // 1\navg [1]           // 1\navg []            // NOT OK :(\n```\n\n### `and`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A_{b}}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A_{b}$ is of type $[\\textbf{Bool}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if every element of $A_{b}$ is true.\n\n**Usage**\n\n```\n// Language: Clean\n\nand [False, False]  // False\nand [False, True]   // True\nand [True, True]    // True\nand [False]         // False\nand [True]          // True\nand []              // True\n```\n\n### `or`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A_{b}}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A_{b}$ and $R$ are of type $[\\textbf{Bool}]$, and\n- $R$ is of type $\\text{Bool}$.\n\n**Behavior**: returns false if and only if every element of $A_{b}$ is false.\n\n**Usage**\n\n```\n// Language: Clean\n\nor [False, False]  // False\nor [False, True]   // True\nor [True, True]    // True\nor [False]         // False\nor [True]          // True\nor []              // False\n```\n\n---\n\n## Higher-Order Functions\n\n### `takeWhile`\n\n**Signature** \n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: takes elements from the start of $A$ as long as $P$ is true.\n\n**Usage**\n\n```\n// Language: Clean\n\ntakeWhile isOdd  [1, 1, 1]  // [1, 1, 1]\ntakeWhile isOdd  [1, 2, 3]  // [1]\ntakeWhile isEven [1, 2, 3]  // []\ntakeWhile isOdd  []         // []\n```\n\n### `dropWhile`\n\n**Signature** \n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: discards elements from the start of $A$ as long as $P$ is true.\n\n**Usage**\n\n```\n// Language: Clean\n\ndropWhile isOdd  [1, 1, 1]  // []\ndropWhile isOdd  [1, 2, 3]  // [2, 3]\ndropWhile isEven [1, 2, 3]  // [1, 2, 3]\ndropWhile isOdd  []         // []\n```\n\n### `filter`\n\n**Signature** \n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: filters $A$ using $P$.\n\n**Usage**\n\n```\n// Language: Clean\n\nfilter isEven [2, 3, 4]  // [2, 4]\nfilter isEven [1, 2, 3]  // [2, 3]\nfilter isOdd  [1, 2, 3]  // [1]\nfilter isOdd  [2, 3, 4]  // [3]\nfilter isOdd  []         // []\n```\n\n### `foldr`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{k}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{K}\\rightarrow\\textbf{K})$, \n- $k$ and $R$ are of type $\\textbf{K}$, and\n- $A$ is of type $[\\textbf{T}]$.\n\n**Behavior**: folds $A$ using a right-associative operation $f$.\n\n**Usage**\n\n```\n// Language: Clean\n\nfoldr (+) 0 [1, 2, 3]\n// 1 + (2 + (3 + 0))\n// 6\n\nfoldr (+) 0 [3, 2, 1]\n// 3 + (2 + (1 + 0))\n// 6\n\nfoldr (^) 1 [1, 2, 3]\n// 1 ^ (2 ^ (3 ^ 1))\n// 1\n\nfoldr (^) 1 [3, 2, 1]\n// 3 ^ (2 ^ (1 ^ 1))\n// 9\n```\n\n### `foldl`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{t}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{K}\\rightarrow\\textbf{T})$, \n- $t$ is of type $\\textbf{T}$,\n- $A$ is of type $[\\textbf{K}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: folds $A$ using a left-associative operation $f$.\n\n**Usage**\n\n```\n// Language: Clean\n\nfoldl (+) 0 [1, 2, 3]\n// ((0 + 1) + 2) + 3\n// 6\n\nfoldr (+) 0 [3, 2, 1]\n// ((0 + 3) + 2) + 1\n// 6\n\nfoldl (^) 1 [1, 2, 3]\n// ((1 ^ 1) ^ 2) ^ 3\n// 1\n\nfoldl (^) 1 [3, 2, 1]\n// ((1 ^ 3) ^ 2)  ^ 1\n// 1\n```\n\n### `iterate`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{T})$,\n- $a$ is of type $\\textbf{T}$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates an infinite list by repeatedly apply $f$ to $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\niterate ((+) 1) 0  // [0, 1, 2, ...]\niterate ((*) 2) 1  // [1, 2, 4, ...]\niterate toInt   1  // [1, 1, 1, ...]\n```\n\n### `map`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $\\textbf{T}\\rightarrow\\textbf{K}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $[\\textbf{K}]$.\n\n**Behavior**: applies $f$ to every element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nmap isEven  [1, 2, 3]  // [False, True, False]\nmap toReal  [1, 2, 3]  // [1.0, 2.0, 3.0]\nmap ((+) 2) [1, 2, 3]  // [3, 4, 5]\n```\n\n### `scan`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{a}\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{K}\\rightarrow\\textbf{T})$, \n- $a$ is of type $\\textbf{T}$,\n- $B$ is of type $[\\textbf{K}]$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates a list of reduced values from apply $f$ to $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nscan (+) 0 [1, 2, 3]\n// [0, 0 + 1, (0 + 1) + 2, ((0 + 1) + 2) + 3]\n// [0, 1, 3, 6]\n\nscan (+) 0 [3, 2, 1]\n// [0, 0 + 3, (0 + 3) + 2, ((0 + 3) + 2) + 1]\n// [0, 3, 5, 6]\n\nscan (^) 1 [1, 2, 3]\n// [1, 1 ^ 1, (1 ^ 1) ^ 2, ((1 ^ 1) ^ 2) ^ 3]\n// [1, 1, 1, 1]\n\nscan (^) 1 [3, 2, 1]\n// [1, 1 ^ 3, (1 ^ 3) ^ 2, ((1 ^ 3) ^ 2) ^ 1]\n// [1, 1, 1, 1]\n```\n\n### `any`\n\n**Signature** \n\n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns false if and only if $P$ does not hold for any element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nany isEven [1, 2, 3]  // True\nany isOdd  [1, 2, 3]  // True\nany isEven [1, 3, 5]  // False\nany isOdd  [2, 4, 6]  // False\nany isEven []         // False\nany isOdd  []         // False\n```\n\n### `all`\n\n**Signature** \n\n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if $P$ holds for every element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nall isEven [1, 2, 3]  // False\nall isOdd  [1, 2, 3]  // False\nall isEven [2, 4, 6]  // True\nall isOdd  [1, 3, 5]  // True\nall isEven []         // True\nall isOdd  []         // True\n```\n\n---\n\n## Property Functions\n\n### `isEmpty`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is empty or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisEmpty []   // True\nisEmpty [1]  // False\n```\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdmisc":{"title":"Appendix A: StdMisc","content":"\n## Constants\n\n### Undefined Entity\n\n**Implementation**\n\n```\n// Language: Clean\n\nundef :: anyType\nundef = abort \"Run-time error! Program evaluated undefined value?!\"\n```\n\n**Definition**: represents an undefined value.\nForces a program to terminate if it is evaluated.\n\n---\n\n## Functions\n\n### `abort`\n\n**Signature**\n\n```\nabort :: {#Char} -\u003e anyType\nabort    a       =\u003e ...\n```\n\n**Behavior**: terminates the program and return an error message `a`.\n\n**Usage**\n\n```\n// Language: Clean\n \nabort \"Terminated\"  // \"Terminated\"\n```\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdordlist":{"title":"Appendix A: StdOrdList","content":"\n## Basic Functions\n\n### `sort`\n\n**Signature** \n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality and relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: sorts $A$ in ascending order using Merge Sort.\n\n**Usage**\n\n```\n// Language: Clean\n\nsort [1, 1, 1]  // [1, 1, 1]\nsort [1, 2, 3]  // [1, 2, 3]\nsort [2, 1, 3]  // [1, 2, 3]\nsort []         // []\n```\n\n### `maxList`\n\n**Signature** \n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, equality and relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: returns the biggest element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nmaxList of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nmaxList [1, 1, 1]  // 1\nmaxList [1, 2, 3]  // 3\nmaxList []         // NOT OK :(\n```\n\n### `minList`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, equality and relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: returns the smallest element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nminList of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nminList [1, 1, 1]  // 1\nminList [1, 2, 3]  // 1\nminList []         // NOT OK :(\n```\n\n---\n\n## Higher-Order Functions\n\n### `sortBy`\n\n**Signature** \n\n$$\n\\begin{align*}\n{P}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: sorts $A$ using an ordering function $P$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsortBy (\u003e) [1, 1, 1]  // [1, 1, 1]\nsortBy (\u003e) [1, 2, 3]  // [3, 2, 1]\nsortBy (\u003e) [2, 1, 3]  // [3, 2, 1]\nsortby (\u003e) []         // []\n```\n\n### `maxListBy`\n\n**Signature**\n\n$$\n\\begin{align*}\n{P}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the biggest element of $A$ using an ordering function $P$.\nResults in a run-time error if $A$ is empty.\n\n```\nmaxListBy of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nmaxListBy (\u003c) [1, 2, 3]  // 3\nmaxListBy (\u003e) [1, 1, 1]  // 1\nmaxListBy (\u003e) [1, 2, 3]  // 1\nmaxListBy (\u003e) []         // NOT OK :(\n```\n\n### `minListBy`\n\n**Signature** \n\n$$\n\\begin{align*}\n{P}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the smallest element of $A$ using an ordering function $P$.\nA run-time error will be thrown if $A$ is empty.\n\n```\nminListBy of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nminListBy (\u003c) [1, 2, 3]  // 1\nminListBy (\u003e) [1, 1, 1]  // 1\nminListBy (\u003e) [1, 2, 3]  // 3\nminListBy (\u003e) []         // NOT OK :(\n```\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdoverloaded":{"title":"Appendix A: StdOverloaded","content":"\n## Operations\n\n### Addition\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: adds $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass + T\nwhere:\n    (+) infixl 6 :: T T -\u003e T\n```\n\n### Subtraction\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: subtracts $b$ from $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass + T\nwhere:\n    (-) infixl 6 :: T T -\u003e T\n```\n\n### Multiplication\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: multiplies $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass * T\nwhere:\n    (*) infixl 7 :: T T -\u003e T\n```\n\n### Division\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{a}\\rightarrow{a}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is a generic type.\n\n**Behavior**: divides $a$ with $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass / T\nwhere:\n    (/) infixl 7 :: T T -\u003e T\n```\n\n### Exponentiation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: raises $a$ to the power of $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass ^ T\nwhere:\n    (^) infixl 7 :: T T -\u003e T\n```\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: checks if $a$ and $b$ are equal.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass == T\nwhere:\n    (==) infixl 4 :: T T -\u003e T\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: checks if $a$ is less than $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass \u003c T\nwhere:\n    (\u003c) infixl 4 :: T T -\u003e T\n```\n\n### Slicing\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow(i,\\ j)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type, and\n- $i$ and $j$ are of type $\\textbf{Int}$.\n\n**Behavior**: slices $[i,\\ j]$ interval from $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass % T\nwhere:\n    (%) infixl 9 :: T (Int, Int) -\u003e T\n```\n\n### Concatenation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: joins $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass +++ T\nwhere:\n    (+++) infixl 5 :: T T -\u003e T\n```\n\n### Modulo\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: $a\\mod{b}$\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass mod T\nwhere:\n    (mod) infixl 7 :: T T -\u003e T\n```\n\n### Reminder Of Division\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: reminder after dividing $a$ with $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass rem T\nwhere:\n    (rem) infixl 7 :: T T -\u003e T\n```\n\n### Negate\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: negates $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass ~ T\nwhere:\n    ~ :: T -\u003e T\n```\n\n---\n\n## Units\n\n### Zero Unit\n\n**Behavior**: unit element for addition.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass zero T\nwhere:\n    zero :: T\n```\n\n### One Unit\n\n**Behavior**: unit element for multiplication.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass one T\nwhere:\n    one :: T\n```\n\n---\n\n## Functions\n\n### `inc`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: adds $a$ by its one unit.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass inc T\nwhere:\n    inc :: T -\u003e T\n```\n\n### `dec`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: subtracts $a$ by its one unit.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass dec T\nwhere:\n    dec :: T -\u003e T\n```\n\n### `abs`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: returns absolute value of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass abs T\nwhere:\n    abs :: T -\u003e T\n```\n\n### `sign`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: returns sign of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sign T\nwhere:\n    sign :: T -\u003e Int\n```\n\n### `isEven`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if $a$ is even.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass isEven T\nwhere:\n    isEven :: T -\u003e Bool\n```\n\n### `isOdd`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if $a$ is odd.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass isOdd T\nwhere:\n    isOdd :: T -\u003e Bool\n```\n\n### `length`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: returns length of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass length T\nwhere:\n    length :: (T a) -\u003e Bool\n```\n\n### `gcd`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type. \n\n**Behavior**: returns greatest common divisor of $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass gcd T\nwhere:\n    gcd :: T T -\u003e T\n```\n\n### `lcm`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type. \n\n**Behavior**: returns least common multiple of $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass lcm T\nwhere:\n    lcm :: T T -\u003e T\n```\n\n### `ln`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns natural log of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass ln T\nwhere:\n    ln :: T -\u003e T\n```\n\n### `log10`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns logarithm base $10$ of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass log10 T\nwhere:\n    log10 :: T -\u003e T\n```\n\n### `exp`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns $e$ raise to the power of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass exp T\nwhere:\n    exp :: T -\u003e T\n```\n\n### `sqrt`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns square root of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sqrt T\nwhere:\n    sqrt :: T -\u003e T\n```\n\n### `sin`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sin T\nwhere:\n    sin :: T -\u003e T\n```\n\n### `cos`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass cos T\nwhere:\n    cos :: T -\u003e T\n```\n\n### `tan`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass tan T\nwhere:\n    tan :: T -\u003e T\n```\n\n### `asin`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass asin T\nwhere:\n    asin :: T -\u003e T\n```\n\n### `acos`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass acos T\nwhere:\n    acos :: T -\u003e T\n```\n\n### `atan`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sin T\nwhere:\n    sin :: T -\u003e T\n```\n\n### `sinh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns hyperbolic sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sinh T\nwhere:\n    sinh :: T -\u003e T\n```\n\n### `cosh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns hyperbolic cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass cosh T\nwhere:\n    cosh :: T -\u003e T\n```\n\n### `tanh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns hyperbolic tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass tanh T\nwhere:\n    tanh :: T -\u003e T\n```\n\n### `asinh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of hyperbolic sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass asinh T\nwhere:\n    asinh :: T -\u003e T\n```\n\n### `acosh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of hyperbolic cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass acosh T\nwhere:\n    acosh :: T -\u003e T\n```\n\n### `atanh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of hyperbolic tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass atanh T\nwhere:\n    atanh :: T -\u003e T\n```\n\n---\n\n## Conversion Functions\n\n### `toInt`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: converts $a$ to $\\textbf{Int}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toInt T\nwhere:\n    toInt :: T -\u003e Int\n```\n\n### `toReal`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Real}$.\n\n**Behavior**: converts $a$ to $\\textbf{Real}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toReal T\nwhere:\n    toReal :: T -\u003e Real\n```\n\n### `toChar`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Char}$.\n\n**Behavior**: converts $a$ to $\\textbf{Char}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toChar T\nwhere:\n    toChar :: T -\u003e Char\n```\n\n### `toBool`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: converts $a$ to $\\textbf{Bool}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toBool T\nwhere:\n    toBool :: T -\u003e Bool\n```\n\n### `toString`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and \n- $R$ is of type $\\textbf{String}$.\n\n**Behavior**: converts $a$ to $\\textbf{String}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toString T\nwhere:\n    toString :: T -\u003e String\n```\n\n### `fromInt`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Int}$, and\n- $R$ is of a generic type.\n\n**Behavior**: converts an integer $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromInt T\nwhere:\n    fromInt :: Int -\u003e T\n```\n\n### `fromReal`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Real}$, and\n- $R$ is of a generic type.\n\n**Behavior**: converts a real number $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromReal T\nwhere:\n    fromReal :: Real -\u003e T\n```\n\n### `fromChar`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $a$ is of a generic type.\n\n**Behavior**: converts a character $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromChar T\nwhere:\n    fromChar :: Char -\u003e T\n```\n\n### `fromBool`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Bool}$, and\n-  $R$ is of a generic type.\n\n**Behavior**: converts a Boolean $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromBool T\nwhere:\n    fromBool :: Bool -\u003e T\n```\n\n### `fromString`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{String}$, and\n- $R$ is of a generic type. \n\n**Behavior**: converts a string $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromString T\nwhere:\n    fromString :: String -\u003e T\n```\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdreal":{"title":"Appendix A: StdReal","content":"\n## Introduction\n\nThis section of **Appendix A** discusses operations and functions defined within Standard Real and, by extension, the Standard Environment.\n\nThe operations and functions of this module primarily interacts with real numbers.\n\n## Constants\n\n### Zero Unit\n\n**Implementation**\n\n```\n// Language: Clean\n\nzero ::  Real\nzero :== 0.0\n```\n\n**Definition**: represents the value zero for real numbers.\n\n### One Unit\n\n**Implementation**\n\n```\n// Language: Clean\n\none ::  Real\none :== 1.0\n```\n\n**Definition**: represents the value one for real numbers.\n\n### Infinity Representation\n\n**Implementation**\n\n```\n// Language: Clean\n\nInfinity ::  Real\nInfinity :== 1E9999\n```\n\n**Definition**: represents the largest value for real numbers.\n\n### Not-A-Number Representation\n\n**Implementation**\n\n```\n// Language: Clean\n\nNaN ::  Real\nNaN :== 1E9999+(-1E9999)\n```\n\n**Definition**: represents floating point values which are not undefined.\n\nSee also [NaN](https://en.wikipedia.org/wiki/NaN).\n\n---\n\n## Arithmetic Operations\n\n### Negation\n\n**Signature**\n\n```\n// Language: Clean\n\n~ :: Real -\u003e Real\n~    a    =  ...\n```\n\n**Behavior**: inverts the sign of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\n~  1.0   // -1.0\n~  0.0   //  0.0\n~(-1.0)  //  1.0\n```\n\n### Addition\n\n**Signature**\n\n\n```\n// Language: Clean\n \n(+) infixl 6 :: Real Real -\u003e Real\n(+)             a    b    =  ...\n```\n\n**Behavior**: adds `a` and `b` together.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  +   1.5   //  4.0\n  2.5  + (-1.5)  //  1.5\n(-2.5) +   1.5   // -1.0\n(-2.5) + (-1.5)  // -4.0\n```\n\n### Subtraction\n\n**Signature**\n\n```\n// Language: Clean\n \n(-) infixl 6 :: Real Real -\u003e Real\n(-)             a    b    =  ...\n```\n\n**Behavior**: subtracts `b` from `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  -   1.5   //  1.0\n  2.5  - (-1.5)  //  4.0\n(-2.5) -   1.5   // -1.5\n(-2.5) - (-1.5)  // -1.0\n```\n\n### Multiplication\n\n**Signature**\n\n```\n// Language: Clean\n \n(*) infixl 7 :: Real Real -\u003e Real\n(*)             a    b    =  ...\n```\n\n**Behavior**: multiplies `a` with `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  *   1.5   //  3.75\n  2.5  * (-1.5)  // -3.75\n(-2.5) *   1.5   // -3.75\n(-2.5) * (-1.5)  //  3.75\n```\n\n### Division\n\n**Signature**\n\n```\n// Language: Clean\n\n(/) infixl 7 :: Real Real -\u003e Real\n(/)             a    b    =  ...\n```\n\n**Behavior**: divides `a` with `b`. \n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  /   1.5   //  1.66666666666667\n  2.5  / (-1.5)  // -1.66666666666667\n(-2.5) /   1.5   // -1.66666666666667\n(-2.5) / (-1.5)  //  1.66666666666667\n  1.0  /   0.0   //  #INF\n(-1.0) /   0.0   // -#INF\n  0.0  /   0.0   //  #NaN\n```\n\n### Exponentiation\n\n**Signature**\n\n```\n// Language: Clean\n\n(^) infixr 8 :: Real Real -\u003e Real\n(^)             a    b    =  ...\n```\n\n**Behavior**: raises `a` to the `b`-th power.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  ^   1.5   //  3.95284707521047\n  2.5  ^ (-1.5)  //  0.25298221281347\n(-2.5) ^   1.5   //  #NAN\n(-2.5) ^ (-1.5)  //  #NAN\n  0.0  ^   0.0   //  1.0\n  0.0  ^   1.0   //  0.0\n  0.0  ^ (-1.0)  //  #INF\n```\n\n---\n\n## Relational Operations\n\nThere are six relational operations, and they share the same behavior.\nThat is, they compare floating point values of two real numbers, then return a Boolean value.\n\nA rather impressive feature of the language is that equality comparison between two floating point values is allowed.\n\n### Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(==) infix 4 :: Real Real -\u003e Bool\n(==)            a    b    =  ...\n```\n\n**Behavior**: returns true if and only if `a` is equal to `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  ==   2.0   // False\n(-5.0) ==   2.0   // False\n  5.0  == (-2.0)  // False\n(-5.0) == (-2.0)  // False\n(-2.0) == (-2.0)  // True\n```\n\n### Not Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c\u003e) infix 4 :: Real Real -\u003e Bool\n(\u003c\u003e)            a    b    =  ...\n```\n\n**Behavior**: returns false if and only if `a` is equal to `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003c\u003e   2.0   // True\n(-5.0) \u003c\u003e   2.0   // True\n  5.0  \u003c\u003e (-2.0)  // True\n(-5.0) \u003c\u003e (-2.0)  // True\n(-2.0) \u003c\u003e (-2.0)  // False\n```\n\n### Less Than\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c) infix 4 :: Real Real -\u003e Bool\n(\u003c)            a    b    =  ...\n```\n\n**Behavior**: returns true if and only if `a` is strictly less than `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003c   2.0   // False\n(-5.0) \u003c   2.0   // True\n  5.0  \u003c (-2.0)  // False\n(-5.0) \u003c (-2.0)  // True\n(-2.0) \u003c (-2.0)  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003c=) infix 4 :: Real Real -\u003e Bool\n(\u003c=)            a    b    =  ...\n```\n\n**Behavior**: returns false if and only if `a` is strictly greater than `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003c=   2.0   // False\n(-5.0) \u003c=   2.0   // True\n  5.0  \u003c= (-2.0)  // False\n(-5.0) \u003c= (-2.0)  // True\n(-2.0) \u003c= (-2.0)  // True\n```\n\n### Greater Than\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003e) infix 4 :: Real Real -\u003e Bool\n(\u003e)            a    b    =  ...\n```\n\n**Behavior**: returns true if and only if `a` is strictly greater than `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003e   2.0   // True\n(-5.0) \u003e   2.0   // False\n  5.0  \u003e (-2.0)  // True\n(-5.0) \u003e (-2.0)  // False\n(-2.0) \u003e (-2.0)  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n```\n// Language: Clean\n\n(\u003e=) infix 4 :: Real Real -\u003e Bool\n(\u003e=)            a    b    =  ...\n```\n\n**Behavior**: returns false if and only if `a` is strictly less than `b`.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003e=   2.0   // True\n(-5.0) \u003e=   2.0   // False\n  5.0  \u003e= (-2.0)  // True\n(-5.0) \u003e= (-2.0)  // False\n(-2.0) \u003e= (-2.0)  // True\n```\n\n---\n\n## Basic Functions\n\n### `sign`\n\n**Signature**\n\n```\n// Language: Clean\n\nsign :: Real -\u003e Int\nsign    a    =  ...\n```\n\n**Behavior**: returns sign of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nsign   1.0   //  1\nsign   0.0   //  0\nsign (-1.0)  // -1\n```\n\n### `abs`\n\n**Signature**\n\n```\n// Language: Clean\n\nabs :: Real -\u003e Real\nabs    a    =  ...\n```\n\n**Behavior**: returns absolute value of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nabs   1.0   // 1.0\nabs   0.0   // 0.0\nabs (-1.0)  // 1.0\n```\n\n### `entier`\n\n**Signature**\n\n```\n// Language: Clean\n\nentier :: Real -\u003e Int\nentier    a    =  ...\n```\n\n**Behavior**: returns floor of `a`.\nThis function is technically a type conversion function.\n\n**Usage**\n\n```\n// Language: Clean\n\nentier   1.5   //  1\nentier   0.0   //  0\nentier (-1.5)  // -2\n```\n\n### `ln`\n\n**Signature**\n\n```\n// Language: Clean\n\nln :: Real -\u003e Real\nln    a    =  ...\n```\n\n**Behavior**: returns natural logarithm of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nln   2.5   //  0.916290731874155\nln   1.5   // -1.405465108108164\nln   0.0   // -#INF\nln (-1.5)  //  #NAN\nln (-2.5)  //  #NAN\n```\n\n### `log10`\n\n**Signature**\n\n```\n// Language: Clean\n\nlog10 :: Real -\u003e Real\nlog10    a    =  ...\n```\n\n**Behavior**: returns logarithm base ten of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nlog10   2.5   //  0.397940008672038\nlog10   1.5   // -0.176091259055681\nlog10   0.0   // -#INF\nlog10 (-1.5)  //  #NAN\nlog10 (-2.5)  //  #NAN\n```\n\n### `exp`\n\n**Signature**\n\n```\n// Language: Clean\n\nexp :: Real -\u003e Real\nexp    a    =  ...\n```\n\n**Behavior**: raises [Euler's number](https://en.wikipedia.org/wiki/E_\\(mathematical_constant\\)) to the power of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nexp   2.5   // 12.1824939607035\nexp   1.5   //  4.48168907033806\nexp   0.0   //  1.0\nexp (-1.5)  //  0.22313016014843\nexp (-2.5)  //  0.0820849986238988\n```\n\n### `sqrt`\n\n**Signature**\n\n```\n// Language: Clean\n\nsqrt :: Real -\u003e Real\nsqrt    a    =  ...\n```\n\n**Behavior**: returns square root of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nsqrt   2.5   // 1.58113883008419\nsqrt   1.5   // 1.22474487139159\nsqrt   0.0   // 0.0\nsqrt (-1.5)  // #NAN\nsqrt (-2.5)  // #NAN\n```\n\n---\n\n## Trigonometric Functions\n\n### `sin`\n\n**Signature**\n\n```\n// Language: Clean\n\nsin :: Real -\u003e Real\nsin    a    =  ...\n```\n\n**Behavior**: returns sine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nsin   2.5   //  0.598472144103956\nsin   1.5   //  0.997494986604054\nsin   0.0   //  0.0\nsin (-1.5)  // -0.997494986604054\nsin (-2.5)  // -0.598472144103956\n```\n\n### `cos`\n\n**Signature**\n\n```\n// Language: Clean\n\ncos :: Real -\u003e Real\ncos    a    =  ...\n```\n\n**Behavior**: returns cosine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\ncos   2.5   // -0.801143615546934\ncos   1.5   //  0.0707372016677029\ncos   0.0   //  1.0\ncos (-1.5)  //  0.0707372016677029\ncos (-2.5)  // -0.801143615546934\n```\n\n### `tan`\n\n**Signature**\n\n```\n// Language: Clean\n\ntan :: Real -\u003e Real\ntan    a    =  ...\n```\n\n**Behavior**: returns tangent of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\ntan   2.5   // - 0.74702229723866\ntan   1.5   //  14.1014199471717\ntan   0.0   //   0.0\ntan (-1.5)  // -14.1014199471717\ntan (-2.5)  //   0.74702229723866\n```\n\n### `asin`\n\n**Signature**\n\n```\n// Language: Clean\n\nasin :: Real -\u003e Real\nasin    a    =  ...\n```\n\n**Behavior**: returns inverse sine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nasin   2.5   //  #NAN\nasin   1.5   //  #NAN\nasin   0.5   //  0.523598775598299\nasin   0.0   //  0.0\nasin (-0.5)  // -0.523598775598299\nasin (-1.5)  //  #NAN\nasin (-2.5)  //  #NAN\n```\n\n### `acos`\n\n**Signature**\n\n```\n// Language: Clean\n\nacos :: Real -\u003e Real\nacos    a    =  ...\n```\n\n**Behavior**: returns inverse cosine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nacos   2.5   // #NAN\nacos   1.5   // #NAN\nacos   0.5   // 1.0471975511966\nacos   0.0   // 1.5707963267949\nacos (-0.5)  // 2.0943951023932\nacos (-1.5)  // #NAN\nacos (-2.5)  // #NAN\n```\n\n### `atan`\n\n**Signature**\n\n```\n// Language: Clean\n\natan :: Real -\u003e Real\natan    a    =  ...\n```\n\n**Behavior**: returns inverse tangent of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\natan   2.5   //  1.19028994968253\natan   1.5   //  0.982793723247329\natan   0.5   //  0.463647609000806\natan   0.0   //  0.0\natan (-0.5)  // -0.463647609000806\natan (-1.5)  // -0.982793723247329\natan (-2.5)  // -1.19028994968253\n```\n\n### `sinh`\n\n**Signature**\n\n```\n// Language: Clean\n\nsinh :: Real -\u003e Real\nsinh    a    =  ...\n```\n\n**Behavior**: returns hyperbolic sine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nsinh   2.5   //  6.05020448103979\nsinh   1.5   //  2.12927945509482\nsinh   0.5   //  0.521095305493747\nsinh   0.0   //  0.0\nsinh (-0.5)  // -0.521095305493747\nsinh (-1.5)  // -2.12927945509482\nsinh (-2.5)  // -6.05020448103979\n```\n\n### `cosh`\n\n**Signature**\n\n```\n// Language: Clean\n\ncosh :: Real -\u003e Real\ncosh    a    =  ...\n```\n\n**Behavior**: returns hyperbolic cosine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\ncosh   2.5   //  6.13228947966369\ncosh   1.5   //  2.35240961524325\ncosh   0.5   //  1.12762596520638\ncosh   0.0   //  1.0\ncosh (-0.5)  // -1.12762596520638\ncosh (-1.5)  // -2.35240961524325\ncosh (-2.5)  // -6.13228947966369\n```\n\n### `tanh`\n\n**Signature**\n\n```\n// Language: Clean\n\ntanh :: Real -\u003e Real\ntanh    a    =  ...\n```\n\n**Behavior**: returns hyperbolic tangent of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\ntanh   2.5   //  0.98661429815143\ntanh   1.5   //  0.905148253644866\ntanh   0.5   //  0.46211715726001\ntanh   0.0   //  0.0\ntanh (-0.5)  // -0.46211715726001\ntanh (-1.5)  // -0.905148253644866\ntanh (-2.5)  // -0.98661429815143\n```\n\n### `asinh`\n\n**Signature**\n\n```\n// Language: Clean\n\nasinh :: Real -\u003e Real\nasinh    a    =  ...\n```\n\n**Behavior**: returns inverse hyperbolic sine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nasinh   2.5   //  1.6472311463711\nasinh   1.5   //  1.19476321728711\nasinh   0.5   //  0.481211825059604\nasinh   0.0   //  0.0\nasinh (-0.5)  // -0.481211825059604\nasinh (-1.5)  // -1.19476321728711\nasinh (-2.5)  // -1.6472311463711\n```\n\n### `acosh`\n\n**Signature**\n\n```\n// Language: Clean\n\nacosh :: Real -\u003e Real\nacosh    a    =  ...\n```\n\n**Behavior**: returns inverse hyperbolic cosine of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\nacosh   2.5   // 1.56679923697241\nacosh   1.5   // 0.962423650119207\nacosh   0.5   // #NAN\nacosh   0.0   // #NAN\nacosh (-0.5)  // #NAN\nacosh (-1.5)  // #NAN\nacosh (-2.5)  // #NAN\n```\n\n### `atanh`\n\n**Signature**\n\n```\n// Language: Clean\n\natanh :: Real -\u003e Real\natanh    a    =  ...\n```\n\n**Behavior**: returns inverse hyperbolic tangent of `a`.\n\n**Usage**\n\n```\n// Language: Clean\n\natanh   2.5   //  #NAN\natanh   1.5   //  #NAN\natanh   0.5   //  0.549306144334055\natanh   0.0   //  0.0\natanh (-0.5)  // -0.549306144334055\natanh (-1.5)  //  #NAN\natanh (-2.5)  //  #NAN\n```\n\n---\n\n## Property Functions\n\n### `isNaN`\n\n**Signature**\n\n```\n// Language: Clean\n\nisNaN :: Real -\u003e Bool\nisNaN    a    =  ...\n```\n\n**Behavior**: returns true if and only if `a` is not representable.\n\n**Usage**\n\n```\n// Language: Clean\n\nisNaN  2.0               // False\nisNaN  0.0               // False\nisNaN (sqrt (-1.0))      // True\nisNaN (ln   (-1.0))      // True\nisNaN ((-1.0) /   0.0)   // False\nisNaN (  0.0  ^ (-1.0))  // False\n```\n\n### `isInfinity`\n\n**Signature**\n\n```\n// Language: Clean\n\nisInfinity :: Real -\u003e Bool\nisInfinity    a    =  ...\n```\n\n**Behavior**: returns true if and only if `a` is too large to represent.\n\n**Usage**\n\n```\n// Language: Clean\n\nisInfinity 2.0                // False\nisInfinity 0.0                // False\nisInfinity (sqrt (-1.0))      // False\nisInfinity (ln   (-1.0))      // False\nisInfinity ((-1.0) /   0.0)   // True\nisInfinity (  0.0  ^ (-1.0))  // True\n```\n\n### `isFinite`\n\n**Signature**\n\n```\n// Language: Clean\n\nisFinite :: Real -\u003e Bool\nisFinite    a    =  ...\n```\n\n**Behavior**: returns false if and only if `a` is too large to represent.\n\n**Usage**\n\n```\n// Language: Clean\n\nisFinite 2.0                // True\nisFinite 0.0                // True\nisFinite (sqrt (-1.0))      // False\nisFinite (ln   (-1.0))      // False\nisFinite ((-1.0) /   0.0)   // False\nisFinite (  0.0  ^ (-1.0))  // False\n```\n\n---\n\n\n## Conversions To Real Number Type\n\nThis group of functions explicitly converts other types to real number type \nThe function shares the same name, which isÂ `toReal`, but they behave differently based on the original type.\n\n### From Integer Type\n\n**Signature**\n\n```\n// Language: Clean\n\ntoReal :: Int -\u003e Real\ntoReal    a   =  ...\n```\n\n**Behavior**: converts `a` to a real number.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoReal   2   //  2.0\ntoReal   1   //  1.0\ntoReal   0   //  0.0\ntoReal (-1)  // -1.0\ntoReal (-2)  // -2.0\n```\n\n### From String Type\n\n**Signature**\n\n```\n// Language: Clean\n\ntoReal :: String -\u003e Real\ntoReal    a      =  ...\n```\n\n**Behavior**: parses a string `a` to an real number.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoReal \"1.0\"   //  1.0\ntoReal \"1\"     //  1.0\ntoReal \"0\"     //  0.0\ntoReal \"-1\"    // -1.0\ntoReal \"-1.0\"  //  1.0\n```\n\n---\n\n## Conversions From Real Number Type\n\nThis group of functions explicitly converts real number type to other types.\nThe function shares the same name, which is `fromReal`, but the desired type must be unambiguous.\n\n### To Integer Type\n\n**Signature**\n\n```\nfromReal :: Real -\u003e Int\nfromReal    a    =  ...\n```\n\n**Behavior**: rounds `a` to its nearest integer.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: Int\nexpr =  fromReal   1.9   //  2\nexpr =  fromReal   1.4   //  1\nexpr =  fromReal (-1.4)  // -1\nexpr =  fromReal (-1.9)  // -2\n```\n\n### To String Type\n\n**Signature**\n\n```\n// Language: Clean\n\nfromReal :: Real -\u003e {#Char}\nfromReal    a    =  ...\n```\n\n**Behavior**: converts a real number `a` into a string.\n\n**Usage**\n\n```\n// Language: Clean\n\nexpr :: {#Char}\nexpr =  fromReal   1.9   // \"1.9\"\nexpr =  fromReal   1.4   // \"1.4\"\nexpr =  fromReal (-1.4)  // \"-1.4\"\nexpr =  fromReal (-1.9)  // \"-1.9\"\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdstring":{"title":"Appendix A: StdString","content":"\n## Basic Operations \n\n### Concatenation\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$, $B$, and $R$ are of type $\\textbf{String}$.\n\n**Behavior**: joins$B$ to the end of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n \n\"123\" +++ \"45\"  // \"12345\"\n\"123\" +++ \"4\"   // \"1234\"\n\"123\" +++ \"\"    // \"123\"\n```\n\n### Slicing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow(i, j)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A, R$ are of type $\\textbf{String}$, and\n- $i, j$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns elements of $A$ which are inside $[i, j]$ interval.\n\n**Usage**\n\n```\n// Language: Clean\n \n\"123\" % (  2,  4)  // \"3\"\n\"123\" % (  0,  2)  // \"123\"\n\"123\" % ((-1), 0)  // \"12\"\n\"123\" % ((-2), 5)  // \"123\"\n```\n\n### Update\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow(i,\\ a)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ and $R$ are of type $\\textbf{String}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $a$ is of type $\\textbf{Char}$.\n\n**Behavior**: updates element at $i$-th index of $A$ with $a$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nIndex too high in UPDATE string.\n\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n\"abcde\" := (  5,  'X')  // NOT OK :(\n\"abcde\" := (  2,  'C')  // \"abCde\"\n\"abcde\" := (  0,  'A')  // \"Abcde\"\n\"abcde\" := ((-1), 'A')  // NOT OK :(\n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   == \"\"    // True\n\"12\" == \"12\"  // True\n\"12\" == \"1\"   // False\n\"1\"  == \"12\"  // False\n\"12\" == \"13\"  // False\n\"13\" == \"12\"  // False\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is not equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003c\u003e \"\"    // False\n\"12\" \u003c\u003e \"12\"  // False\n\"12\" \u003c\u003e \"1\"   // True\n\"1\"  \u003c\u003e \"12\"  // True\n\"12\" \u003c\u003e \"13\"  // True\n\"13\" \u003c\u003e \"12\"  // True\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is less than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003c \"\"    // False\n\"12\" \u003c \"12\"  // False\n\"12\" \u003c \"1\"   // False\n\"1\"  \u003c \"12\"  // True\n\"12\" \u003c \"13\"  // True\n\"13\" \u003c \"12\"  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is less than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003c= \"\"    // True\n\"12\" \u003c= \"12\"  // True\n\"12\" \u003c= \"1\"   // False\n\"1\"  \u003c= \"12\"  // True\n\"12\" \u003c= \"13\"  // True\n\"13\" \u003c= \"12\"  // False\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is greater than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003e \"\"    // False\n\"12\" \u003e \"12\"  // False\n\"12\" \u003e \"1\"   // True\n\"1\"  \u003e \"12\"  // False\n\"12\" \u003e \"13\"  // False\n\"13\" \u003e \"12\"  // True\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is greater than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n// Language: Clean\n\n\"\"   \u003e= \"\"    // True\n\"12\" \u003e= \"12\"  // True\n\"12\" \u003e= \"1\"   // True\n\"1\"  \u003e= \"12\"  // False\n\"12\" \u003e= \"13\"  // False\n\"13\" \u003e= \"12\"  // True\n```\n\n[Back to top](#)\n\n---\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-a/stdtuple":{"title":"Appendix A: StdTuple","content":"\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if two tuples are equal or not.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx == Ty) \u0026\u0026 (Kx == Ky)  // for 2-tuples\n\n(Tx == Ty) \u0026\u0026 (Kx == Ky) \u0026\u0026 (Vx == Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') == (1, 'a')  // True\n(1, 'a') == (1, 'b')  // False\n(1, 'a') == (1, 'b')  // False\n(2, 'a') == (1, 'a')  // False\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if two tuples are not equal or not.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003c\u003e Ty) \u0026\u0026 (Kx \u003c\u003e Ky)  // for 2-tuples\n\n(Tx \u003c\u003e Ty) \u0026\u0026 (Kx \u003c\u003e Ky) \u0026\u0026 (Vx \u003c\u003e Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003c\u003e (1, 'a')  // False\n(1, 'a') \u003c\u003e (1, 'b')  // False\n(1, 'a') \u003c\u003e (1, 'b')  // False\n(2, 'a') \u003c\u003e (1, 'a')  // False\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is less than another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003c Ty) \u0026\u0026 (Kx \u003c Ky)  // for 2-tuples\n\n(Tx \u003c Ty) \u0026\u0026 (Kx \u003c Ky) \u0026\u0026 (Vx \u003c Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003c (1, 'a')  // False\n(1, 'a') \u003c (1, 'b')  // False\n(1, 'a') \u003c (1, 'b')  // False\n(2, 'a') \u003c (1, 'a')  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is less than or equal to another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003c= Ty) \u0026\u0026 (Kx \u003c= Ky)  // for 2-tuples\n\n(Tx \u003c= Ty) \u0026\u0026 (Kx \u003c= Ky) \u0026\u0026 (Vx \u003c= Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003c= (1, 'a')  // True\n(1, 'a') \u003c= (1, 'b')  // True\n(1, 'a') \u003c= (1, 'b')  // True\n(2, 'a') \u003c= (1, 'a')  // False\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is greater than another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003e Ty) \u0026\u0026 (Kx \u003e Ky)  // for 2-tuples\n\n(Tx \u003e Ty) \u0026\u0026 (Kx \u003e Ky) \u0026\u0026 (Vx \u003e Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003e (1, 'a')  // True\n(1, 'a') \u003e (1, 'b')  // True\n(1, 'a') \u003e (1, 'b')  // True\n(2, 'a') \u003e (1, 'a')  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is greater than or equal to another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003e= Ty) \u0026\u0026 (Kx \u003e= Ky)  // for 2-tuples\n\n(Tx \u003e= Ty) \u0026\u0026 (Kx \u003e= Ky) \u0026\u0026 (Vx \u003e= Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003e= (1, 'a')  // False\n(1, 'a') \u003e= (1, 'b')  // False\n(1, 'a') \u003e= (1, 'b')  // False\n(2, 'a') \u003e= (1, 'a')  // True\n```\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/appendix-b/_intro":{"title":"Appendix B: Code recipes","content":"\n## Table of contents\n\n- [Introduction](#introduction)\n- [Breaking an integer into its digits](#breaking-an-integer-into-its-digits)\n- [Computing divisors of an integer](#computing-divisors-of-an-integer)\n- [Checking if an integer is prime or not](#checking-if-an-integer-is-prime-or-not)\n\n## Introduction\n\nThis section contains a collection of common and useful functions.\nEach method includes the implementation as well as the explanation.\n\n## Breaking an integer into digits\n\n**Signature** \n\n$$\n\\begin{align*}\n\\text{Int}\\rightarrow[\\text{Int}]\n\\end{align*}\n$$\n\n**Expected result**\n\n```\n// Language: Clean\n\ntoDigits 123  // [1, 2, 3]\ntoDigits 456  // [4, 5, 6]\ntoDigits 1234 // [1, 2, 3, 4]\ntoDigits 4567 // [4, 5, 6, 7]\n```\n\n### Recursion\n\n**Implementation**:\n\n```\n// Language: Clean\n\ntoDigits :: Int -\u003e [Int]\ntoDigits    n \n| (abs n) \u003c 10  =  [n]\n| otherwise     =  (toDigits (n / 10)) ++ [n rem 10]\n```\n\n**Conversion pathway**\n\n$$\n\\begin{align*}\n\\text{Int}\\rightarrow\\text{[Int]}\n\\end{align*}\n$$\n\n**Explanation**:\n\nGiven an integer $n$, the last digit is placed on the end of a list.\nTo get the last digit of $n$, we take advantage of the $\\text{mod}$ operation. \n\nBefore the next iteration, $n$ is divided by $10$, this step removes the last digit of $n$ since it has already been placed in the list.\n\n$\\text{abs}$ expands domain from $[0,\\ \\infty)$ to $(-\\infty,\\ \\infty)$.\n\n### List comprehension\n\n```\n// Language: Clean\n\ntoDigits :: Int -\u003e [Int]\ntoDigits    n   =  [(toInt d) - 48 \\\\ d \u003c-: (toString n)]\n```\n\n**Conversion  pathway**\n\n$$\n\\begin{align*}\n\\text{Int}\\rightarrow\\text{String}\\rightarrow\\text{Char}\\rightarrow\\text{Int}\\rightarrow[\\text{Int}]\n\\end{align*}\n$$\n\n**Explanation**:\n\nSince arrays can be freely converted to lists and vice versa, we can convert $n$ to an array.\n\nIn this case, $n$ is converted into an array of $\\text{Char}$.\n$\\text{toInt}$ then converts each digit of $n$ to $\\text{Int}$.\n\nHowever, the $\\text{Char}\\rightarrow\\text{Int}$ conversions are ASCII based.\nThat is \n- character $1$ converts to integer value $49$, \n- character $2$ converts to integer value $50$, and so on.\n\nIn the final step, an offset value of $48$ is subtracted from the result.\n\n\n[Back to top](#)\n\n---\n\n## Computing divisors of an integer\n\n**Signature**: $\\text{Int}\\rightarrow\\text{[Int]}$\n\n**Expected result**:\n\n```\n// Language: Clean\n\ndivisorsOf 9  // [1, 3, 9]\ndivisorsOf 16 // [1, 2, 4, 8, 16]\ndivisorsOf 2  // [1, 2]\ndivisorsOf 0  // [0]\n```\n\n### List comprehension\n\n```\n// Language: Clean\n\nisDivisible :: Int Int -\u003e Bool\nisDivisible    x   y   =  (x rem y) == 0\n\ndivisorsOf :: Int -\u003e [Int]\ndivisorsOf    0   =  [0]\ndivisorsOf    n   =  [d \\\\ d \u003c- [1..(abs n)] | isDivisible n d]\n```\n\n**Conversions**\n\n$$\n\\text{Int}\\rightarrow[\\text{Int}]\n$$\n\n**Explanation**:\n\nA list of integers is generated.\nIt contains integers in $[1,\\ \\lvert{n}\\rvert]$ interval.\n\nThe helper function $\\text{isDivisible}$ determines which integer will be placed in the list, and which integer will be discarded.\n\nIf an integer $d$ is a divisor of $n$, it is included in the list.\nIf it does not full divide $n$, it is discarded.\n\n[Back to top](#)\n\n---\n\n## Checking if an integer is prime\n\n**Signature**: $\\text{Int} \\rightarrow\\text{Bool}$\n\n**Expected result**:\n\n```\n// Language: Clean\n\nisPrime 9 // False\nisPrime 3 // True\nisPrime 1 // False\nisPrime 0 // False\n```\n\n### Counting divisors list (comprehension)\n\n```\n// Language: Clean\n\nisPrime :: Int -\u003e Bool\nisPrime 0 = False\nisPrime 1 = False\nisPrime n = length (filter isDivisorOfN [d \\\\ d \u003c- ds]) == 0\nwhere\n\tds :: [Int]\n\tds =  [2..(n - 1)]\n\n\tisDivisorOfN :: Int -\u003e Bool\n\tisDivisorOfN k = (n rem k) == 0\n```\n\n**Conversions**: $\\text{Int}\\rightarrow\\text{[Int]}\\rightarrow\\text{Int}\\rightarrow\\text{Bool}$\n\n**Explanation**:\n\nFor $n \\gt 1$, a list of integers from $2$ to $n - 1$ is constructed.\nThe list filtered to only contain divisors of $n$.\n\nIf the divisor list is empty, $n$ is a prime number.\n\n### Using list of booleans\n\n```\nisPrime :: Int -\u003e Bool\nisPrime 0 = False\nisPrime 1 = False\nisPrime n = not (or [n rem d == 0 \\\\ d \u003c- [2..(n - 1)]]) \n```\n\n**Conversions**: $\\text{Int}\\rightarrow\\text{[Int]}\\rightarrow\\text{[Bool]}\\rightarrow\\text{Bool}$\n\n[Back to top](#)\n\n---\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/function/Defining-a-Function":{"title":"Defining a Function","content":"\n## Implementing a Function\n\nA simple function definition consists of one or more function implementations.\n\nSee [Implementing a Function](function/Implementing%20a%20Function.md).\n\n---\n\n## Indirectly Defining a Function\n\nA group of special expressions exists as syntactic sugar.\nThey are compiled down to a function definition.\nBy invoking such an expression, a function is indirectly defined.\n\nSee [Special Expressions](Expressions/Special%20Expressions.md).\n\n---\n\n## Infix Operators\n\nOperators are arity-two functions.\nThey behave and follow similar rules to that of ordinary arity-two functions.\nThe main difference is that operators can be called between its arguments.\n\nSee [Defining an Operator](operator/Defining%20an%20Operator.md).\n\n---\n\n## Typing a Function\n\nA function definition can be explicitly typed to increase readability.\n\nSee [Typing a Function](function/Typing%20a%20Function.md)\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/function/Guarded-Expression-Rules":{"title":"Guarded Expression Rules","content":"\nWhen extending a function implementation with guarded expressions, the guarded expressions follow certain rules.\nViolation of such rules results in a compile-time error.\n\n","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/function/Guarded-Expressions":{"title":"Guarded Expressions","content":"\nA function implementation can have multiple expressions.\n\n## Control Forms of a Guarded Expression\n\nA control function implementation with one guarded expression is written as follows.\n\n```\n// Language: Clean\n\nname param\n| guard = expr\n```\n\nEach guarded expression starts with a vertical bar (`|`).\n\nA control function implementation with three guarded expression is written as follows.\n\n```\n// Language: Clean\n\nname param\n| guardA = exprA\n| guardB = exprB\n| guardC = exprC\n```\n\nA control function implementation with one guarded expressions and a nested guarded expression is written as follows.\n\n```\n// Language: Clean\n\nname param\n| guardA\n    | guardAA = exprAA\n```\n\n### Guarded Expression Rules\n\nGuarded expressions of a function implementation must follow certain rules.\nViolation of such rules results in a compile-time error.\n\nSee [Guarded Expression Rules](function/Guarded%20Expression%20Rules.md).\n\n---\n\n## Selecting a Guarded Expression To Be Evaluated\n\n*Guarded expressions are tried in descending order, and the expression of the first guard yield true is evaluated.*\n\nTo demonstrate, let's define a function called `signum`.\nIt accepts one integer value as argument, and returns the sign.\n\n`signum` can be defined in a few ways to achieve the describe behavior.\nFor the sake of simplicity, it will be defined with one implementation which has three guarded expressions.\n\n```\n// Language: Clean\n\nsignum n\n| n == 0 =  0\n| n \u003e  0 =  1\n| n \u003c  0 = -1\n```\n\nLet's call signum with -2 to investigate this rule.\n\n```\n// Language: CLean\n\nsignum  -2  // ?\n```\n\nThe first guard is tried. \n\n| Guard  # | Guard    | Expression | Result |\n| -------- | -------- | ---------- | ------ |\n| 1        | `n == 0` | `-2 == 0`  | Fail   |\n\nIt evaluates to false, and this guarded expression is not selected.\n\nThe next guard is tried.\n\n| Guard  # | Guard    | Expression | Result |\n| -------- | -------- | ---------- | ------ |\n| 1        | `n == 0` | `-2 == 0`  | Fail   |\n| 2        | `n \u003e  0` | `-2 \u003e  0`  | Fail   |\n\nIt evaluates to false, and this guarded expression is not selected.\n\nThe last guard is tried.\n\n| Guard # | Guard    | Expression | Result |\n| ------- | -------- | ---------- | ------ |\n| 1       | `n == 0` | `-2 == 0`  | Fail   |\n| 2       | `n \u003e  0` | `-2 \u003e  0`  | Fail   |\n| 3       | `n \u003c  0` | `-2 \u003c  0`  | Pass   |\n\nIt evaluates to true, this guarded expression is selected.\n\nThe result is obtained from the expression associated with the third guard, which is -1.\n\n```\n// Language:\n\nsignum -2  // -1\n```\n\n*Guarded expressions are tried only if their function implementation is selected.\nIf a function implementation is not selected, guarded expressions, which belong to it, are not tried.*\n\nTo better demonstrate, an arbitrary function is defined as follows.\n\n```\n// language: Clean\n\nsomeFunction paramA\n| guardAA = expressionAA\n| guardAB = expressionAB\nsomeFunction paramB\n| guardBA = expressionBA\n| guardBB = expressionBB\n```\n\nIn cases where the second implementation is selected, `guardAA` and `guardAB` are skipped.\n\n*Once a function implementation is selected, subsequent implementations are not tried, even if no guarded expression can be selected.*\n\nTo demonstrate, let's modify the definition of `superSafeDivide` and call the definition `superSafeDivideAlt` to avoid confusion.\n\n\n```\nsuperSafeDivide n 0\n| n == 0            = 0\nsuperSafeDivide n m = n / m\n```\n\nThe main difference is `superSafeDivideAlt` no longer explicitly terminates the program.\n\nThe behavior of both function remains similar, but a problem occurs when `superSafeDivideAlt` is called with a non-zero integer and 0.\n\n```\n// Language: Clean\n\nsuperSafeDivideAlt 9 0  // ?\n```\n\nThe first implementation is tried.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `n`       | `9`      | Pass   |\n| 2      | `0`       | `0`      | Pass   |\n\nIt is selected, and it first guard is tried.\n\n| Guard # | Guard    | Expression | Result |\n| ------- | -------- | ---------- | ------ |\n| 1       | `n == 0` | `9 == 0`   | Fail   |\n\nThe first guard is not selected.\n\n\nIn such a case, the function definition is partial, and the function call results in a run-time error.","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/function/Implementation-Rules":{"title":"Implementation Rules","content":"\nWhen defining a function, its implementations must follow a set of rules.\nViolation of these rules results in a compile-time error.\n\nLet's discuss what they are.\n\n## Implementation Rule of Naming\n\n*Implementation of a function must share a single name.*\n\nImplementations of a function should have the same name.\nMore importantly, the name of a function must be unique from other names in the same scope.\n\n---\n\n## Implementation Rule of Grouping\n\n*Implementations of a function must be together.*\n\nNon-comment entities cannot be placed between implementations of a function.\n\n```\n// Language: Clean\n\nbadFunction paramA = ...\n6 + 2\nbadFunction paramB = ...\n```\n\nThe function definition is invalid because implementations of `badFunction` are separated by an expression (`6 + 2`).\n\n---\n\n## Implementation Rule of Signature\n\n\u003e Implementations of a function must share a single signature.\n\n```\n// Language: Clean\n\nbadFunction m 0 = False\nbadFunction m n = m / n\n```\n\nThe first implementation returns a Boolean value, but the second returns an integer.\n\nThe function definition is invalid because implementations of `badFunction` have conflicting signatures.","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/function/Implementing-a-Function":{"title":"Implementing a Function","content":"\n## Control Forms of a Function Implementation\n\nA function definition consists of function implementations.\nLet's discuss what they look like.\n\nA control form of a function implementation with one parameter is written as follows.\n\n```\n// Language: Clean\n \nname param = expr\n```\n\nA control form of a function implementation with two parameters is written as follows.\n\n```\n// Language: Clean\n\nname paramA paramB = expr\n```\n\nThat is parameters are space-separated.\n\n### Implementation Rules\n\nImplementations of a function must follow certain rules.\nViolation of such rules results in a compile-time error.\n\nSee [Implementation Rules](function/Implementation%20Rules.md).\n\n### Extending the Expression of a Function Implementation\n\nOn its own, a function implementation has one expression associated with it.\nThe function implementation has ownership over its expression.\n\nBy introducing guarded expressions, an implementation can have ownership over multiple guarded expressions, instead of just one expression.\n\nSee [Guarded Expressions](function/Guarded%20Expressions.md).\n\n---\n\n## Selecting an Implementation To Be Evaluated\n\nA function definition often contains multiple function implementations.\nOnly one implementation can be selected.\n\n*Implementations are tried in descending order, and the first implementation, whose parameters match with every argument, is selected.*\n\nLet's describe `safeDivide` as a function which:\n- accepts two integers as arguments, \n- returns the result of division, and\n- returns zero when the given denominator is 0.\n\n```\n// Langauge: Clean\n\nsafeDivide 6 2  // 3\nsafeDivide 2 0  // 0\n```\n\nIt can be defined using two implementations.\n\n```\n// Langauge: Clean\n\nsafeDivide m 0 = 0\nsafeDivide m n = m / n\n```\n\nLet's call `safeDivide` with 9 and 6 and investigate.\n\n```\n// Language: Clean\n\nsafeDivide 9 6  // ?\n```\n\nApply the rule to see which implementation is selected.\n\nThe first implementation is tried, and the first parameter matches the first argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `m`       | `9`      | Pass   |\n\nThe second parameter does not match the second argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `m`       | `9`      | Pass   |\n| 2      | `0`       | `6`      | Fail   |\n\nThe first implementation is not selected.\n\nNext, the second implementation is tried, and both parameters match both arguments.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `m`       | `9`      | Pass   |\n| 2      | `n`       | `6`      | Pass   |\n\nThe second implementation is selected.\n\nThe result is obtained from the expression of the second implementation, which is `m / n`.\nIt evaluates to 1.\n\n```\n// Language: Clean\n\nsafeDivide 9 6  // 1\n```\n\nLet's call `safeDivide` with 9 and 0 instead.\n\n```\n// Language: Clean\n\nsafeDivide 9 0\n```\n\nThe first implementation is tried, and the first parameter matches the first argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `m`       | `9`      | Pass   |\n\nThe second parameter matches the second argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `m`       | `9`      | Pass   |\n| 2      | `0`       | `0`      | Pass   |\n\nThe first implementation is select, and the second implementation is not tried.\n\nThe result is obtained from the expression of the first implementation, which is 0.\n\n```\n// Language: Clean\n\nsafeDivide 9 0  // 0\n```\n\nNotice that if implementation order is changed, `safeDivide` would have unintended behaviors.\n\nTo demonstrate, the implementation order of `safeDivide` is changed.\n\n```\n// Language: Clean\n\nsafeDivide m n = m / n\nsafeDivide m 0 = 0\n```\n\nThe second implementation is never reached even if `safeDivide`  is called with `0`.\n\n```\n// Language: Clean\n\nsafeDivide 9 0  // Uh oh\n```\n\nMore importantly, this rule does not perform equality operation.\n\n### No Valid Candidate for Selection\n\nIf none of the implementation is a valid candidate for selection, the function call results in a run-time error.\n\nSee [Partial Functions](function/Partial%20Functions.md).","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/function/Partial-Functions":{"title":"Partial Functions","content":"\nA partially defined function is a function which results in a run-time error when called with values outside of its domain.\n\nLet's imagine a function called `isOne`.\n\nIt simply checks whether a number is one or not.\n\n## Partial Function by Implementation\n\nIt can be defined with two implementations.\n\n```\n// Language: Clean\n\nisOne (-1) = True\nisOne   1  = True\n```\n\nLet's try calling it with one and follow the [Implementation Rule of Selection](function/Implementation%20Rules.md#Implementation%20Rule%20of%20Selection) to make sure that works.\n\n```\n// Language: Clean\n\nisOne 1\n```\n\nThe first implementation is tried.\nThe first parameter does not match the first argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `-1`      | `1`      | Fail   |\n\nThe first implementation is not selection.\n\nThe second implementation is tried.\nThe first parameter matches the first argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `1`       | `1`      | Pass   |\n\nThe second implementation is selection.\n\nThe result of the function call is obtained from the expression associated with the second implementation, which is `True`.\n\n```\n// Language: Clean\n\nisOne 1  // True\n```\n\nWe will make an assumption that it works with  `-1` as well.\n\n```\nisOne -1  // True\n```\n\nLet's call `isOne` with zero.\n\n```\nisOne 0\n```\n\nThe first implementation is tried.\nThe first parameter does not match the first argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `-1`      | `0`      | Fail   |\n\nThe first implementation is not selected.\n\nThe second implementation is tried.\nThe first parameter does not match the first argument.\n\n| Pair # | Parameter | Argument | Result |\n| ------ | --------- | -------- | ------ |\n| 1      | `1`       | `0`      | Fail   |\n\nThe second implementation is not selected either.\n\nAt this point, every implementation of `isOne` is tried, and no implementation is selection.\n\nThe function call results in a run-time error.\n\n```\n// Language: Clean\n\nisOne 0  // Uh oh\n```\n\nWe can conclude that `isOne` is a partial function, because it results in a run-time error when called with values outside of its domain.\n\n---\n\n## Partial Function by Guarded Expression\n\nAlternatively, `isOne` can be define with one implementation which has two guarded expressions.\n\n```\nisOne n\n| n == (-1) = True\n| n ==   1  = True\n```\n\nLet's try calling it with negative one and follow the [Guarded Expression Signature Rule](function/Guarded%20Expression%20Rules.md#Guarded%20Expression%20Signature%20Rule) to make sure that works.\n\n```\n// Language: Clean\n\nisOne -1\n```\n\nThe first implementation is tried.\nThe first parameter does not match the first argument.\n\n| Guard # | Guard       | Result |\n| ------- | ----------- | ------ |\n| 1       | `n == (-1)` | True   |\n\nThe first guard is selected.\n\nThe result of the function call is obtained from the expression associated with the first guard, which is `True`.\n\n```\n// Language: Clean\n\nisOne (-1)  // True\n```\n\nThe same problem arises when called with zero, because this definition of `isOne` is still partial.\n\n---\n\n## Resolving Partial Functions\n\nThere are many ways to completely define a function.\n\nA good way is to change the method in which the function is define.\n\n```\n// Language: Clean\n\nisOne n = n == (-1) || n == 1\n```\n\nThis way, the semantic meaning of the function is preserved.\n\nAdding addition implementations to cover the possible domain of input is also a good way to complete a function.\n\n```\n// Language: Clean\n\nisOne (-1) = True\nisOne   1  = True\nisOne   n  = False\n```\n\nThis definition ensures that the `isOne` will never result in a run-time error by implementing an addition \"catch all\" implementation.\n\nFinally, A built-in function called `abort` helps complete a function by terminating the program early.\n\n```\n// Language: Clean\n\nisOne (-1) = True\nisOne   1  = True\nisOne   n  = abort \"isOne called with values outside of domain.\"\n```\n\nSee [StdMisc](appendix-a/StdMisc.md).","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/function/Typing-a-Function":{"title":"","content":"A control function type may be written as follows.\n\n```\n// Language: Clean\n\nparameterType -\u003e returnType\n```\n\nParameter types are space separated.\n\n```\n// Language: Clean\n\nparamAType paramBType -\u003e returnType\n```\n\n#### Typing Ordinary Functions\n\nA control function definition with one parameter may be explicitly typed as follows.\n\n```\n// Language: Clean\n\nfunctionA :: parameterType -\u003e expressionType\nfunctionA    parameter     =  expression\n```\n\nParameter types are space separated.\n\n```\n// Language: Clean\n\nfunctionB :: paramAType paramBType -\u003e expressionType\nfunctionB    paramA     paramB     =  expression\n```","lastmodified":"2023-06-19T20:30:36.495859819Z","tags":null},"/operator/Defining-an-Operator":{"title":"Defining an Operator","content":"\nAn operator can be defined by placing its name between parentheses.\nIt can be implemented as if it was an ordinary function.\n\n### Control Form of an Operator\n\nA control form of an operator definition is be written as follows.\n\n```\n// Language: Clean\n\n(operator) paramL paramR = expression\n```\n","lastmodified":"2023-06-19T20:30:36.499860059Z","tags":null},"/operator/calling-operators":{"title":"","content":"```\n// Language: Clean\n\n1 + 1  // applied as an operator\n```\n\nTo invoke an operator as an ordinary function, the operator name must be placed inside parentheses, and in front of its arguments.\n\n```\n// Language: Clean\n\n(+) 1 1  // invoked as an ordinary function\n```\n\nWhen applied in infix position, both arguments must be given.\nOperators can be curried, but only when they are invoked as ordinary functions.","lastmodified":"2023-06-19T20:30:36.499860059Z","tags":null},"/operator/operator-associativity":{"title":"Operator Associativity","content":"\nThe associativity is important when evaluating two operators of the same precedence.\n\nThere are three associativities:\n- `infix` for non-associative operators,\n- `infixl` for left-associative operators, and\n- `infixr` for right-associative operators.\n\nThe associativity of an operator is `infixl` by default.","lastmodified":"2023-06-19T20:30:36.499860059Z","tags":null},"/operator/operator-conflict":{"title":"Operator Conflict","content":"\nOperators can conflict with one another.\n\n```\n// Language: Clean\n\n(\u003c=\u003e) infixl 9 :: Bool  Bool  -\u003e Bool\n(\u003c=\u003e)             True  True  =  True\n(\u003c=\u003e)             False False =  True\n(\u003c=\u003e)             _     _     =  False\n\n(--\u003e) infixr 9 :: Bool Bool  -\u003e Bool\n(--\u003e)             True False =  False\n(--\u003e)             _     _    =  True\n```\n\nIt is not allowed to apply operators with equal precedence in an expression in such a way that their associativity conflict.\n\n```\n// Language: Clean\n\nTrue --\u003e False \u003c=\u003e False\n```\n\nThe [logical implication](https://en.wikipedia.org/wiki/Material_conditional) operator (`--\u003e`)  is right-associated.\nIt implies that the expression should be evaluated as follows.\n\n```\n// Language: Clean\n\nTrue --\u003e (False \u003c=\u003e False)\n```\n\nHowever, the [logical equivalence](https://en.wikipedia.org/wiki/Logical_equivalence) operator (`\u003c=\u003e`) is left associated.\nIt implies that the expression should be evaluated as follows.\n\n```\n// Language: Clean\n\n(True --\u003e False) \u003c=\u003e False\n```\n\nSince both operators have the same precedence and the order of evaluation cannot be decided by their associativity, this expression will result in a compile-time error.","lastmodified":"2023-06-19T20:30:36.499860059Z","tags":null},"/operator/operator-precedence":{"title":"","content":"\nThe precedence determines how tightly an operator binds to its argument.\nPrecedence can be between zero and nine with higher number having higher precedence.\n\nThe precedence of an operator is nine by default.","lastmodified":"2023-06-19T20:30:36.499860059Z","tags":null},"/operator/typing-operators":{"title":"Typing Operators","content":"\nA control operator definition may be explicitly typed as follows.\n\n```\n// Language: Clean\n\n(operator) :: paramLType paramRType -\u003e expressionType\n(operator)    paramL     paramR     =  expression\n```\n\nIn addition, operator associativity (`A`) and precedence (`P`) may be specified as well.\n\n```\n// Language: Clean\n\n(operator) A P :: paramLType paramRType -\u003e expressionType\n(operator)        paramL     paramR     =  expression\n```","lastmodified":"2023-06-19T20:30:36.499860059Z","tags":null}}