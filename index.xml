<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cleanpedia on</title><link>https://eurydia.github.io/cleanpedia/</link><description>Recent content in Cleanpedia on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://eurydia.github.io/cleanpedia/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://eurydia.github.io/cleanpedia/Constants/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/Constants/</guid><description>There are two distinct types of constants; constant expressions and constant functions.
Constant Expressions They are computed only once. Multiple reference to the same expression will result in sharing of that expression.</description></item><item><title/><link>https://eurydia.github.io/cleanpedia/Expressions/Case-Expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/Expressions/Case-Expressions/</guid><description>A case..of.. expression matches a given expression with one of its patterns, and a control expression with one pattern may be written as follows.</description></item><item><title/><link>https://eurydia.github.io/cleanpedia/Expressions/Lambda-Expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/Expressions/Lambda-Expressions/</guid><description>Lambda Functions A control lambda function may be written as follows.
1 2 3 // Language: Clean \ parameter = expression Alternatively, dot (.</description></item><item><title/><link>https://eurydia.github.io/cleanpedia/Expressions/Pattern-Match-Expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/Expressions/Pattern-Match-Expressions/</guid><description>A pattern-match expression checks an expression against a pattern, and a control expression may be written as follows.
1 2 3 // Language: Clean expression =: pattern If a given expression matches with the pattern, it yields true.</description></item><item><title/><link>https://eurydia.github.io/cleanpedia/function/Guarded-Expression-Rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/function/Guarded-Expression-Rules/</guid><description>Guarded expressions have rules which they must follow, similar to function implementation rules.
Guarded Expression Signature Rule Expressions of guarded expressions must have a single type.</description></item><item><title/><link>https://eurydia.github.io/cleanpedia/function/Typing-a-Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/function/Typing-a-Function/</guid><description>A control function type may be written as follows.
1 2 3 // Language: Clean parameterType -&amp;gt; returnType Parameter types are space separated.</description></item><item><title/><link>https://eurydia.github.io/cleanpedia/Local-Scopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/Local-Scopes/</guid><description>Let Expressions A let..in.. expression introduces a new scope within another expression.
A control expression with one local definition may be written as follows.</description></item><item><title/><link>https://eurydia.github.io/cleanpedia/operator/calling-operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/operator/calling-operators/</guid><description>1 2 3 // Language: Clean 1 + 1 // applied as an operator To invoke an operator as an ordinary function, the operator name must be placed inside parentheses, and in front of its arguments.</description></item><item><title>Appendix A: Standard Environment</title><link>https://eurydia.github.io/cleanpedia/appendix-a/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/introduction/</guid><description>Introduction This section is referred to by other parts of the reference to increase readability and clarity. It is a summary of the Standard Environment provided by creators of CLEAN.</description></item><item><title>Appendix A: StdArray</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdarray/</guid><description>Basic Operations Indexing Signature
$$ \begin{align*} A\rightarrow{i}\rightarrow{R} \end{align*} $$
where :
$A$ is of type ${\textbf{T}}$, $i$ is of type $\textbf{Int}$, and $R$ is of type $\textbf{T}$.</description></item><item><title>Appendix A: StdBool</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdbool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdbool/</guid><description>Introduction The StdBool module contains implementation for logical operations.
When imported, this module allows for:
evaluation of Boolean expressions, and conversion from Boolean type.</description></item><item><title>Appendix A: StdChar</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdchar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdchar/</guid><description>Introduction The StdChar module contains implementation for operations and functions relating to integer type.
When imported, this module allows for:</description></item><item><title>Appendix A: StdCharList</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdcharlist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdcharlist/</guid><description>Basic Functions cjustify Signature
$$ \begin{align*} n\rightarrow{A}\rightarrow{R} \end{align*} $$
where:
$n$ is of type $\textbf{Int}$, and $A$ and $R$ are of type $[\textbf{Char}]$.</description></item><item><title>Appendix A: StdClass</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdclass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdclass/</guid><description>Arithmetic Classes PlusMin Declaration
1 2 3 // Language: Clean class PlusMin T | (+ T) &amp;amp; (- T) &amp;amp; (zero T) MultDiv Declaration</description></item><item><title>Appendix A: StdInt</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdint/</guid><description>Introduction The StdInt module contains source code for operations and functions relating to integer type.
For integer type, this module implements:</description></item><item><title>Appendix A: StdList</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdlist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdlist/</guid><description>Basic Operations Concatenation Signature
$$ \begin{align*} A\rightarrow{B}\rightarrow{R} \end{align*} $$
where
$A$, $B$, and $R$ are of type $[\textbf{T}]$. Behavior: appends $B$ to the end of $A$.</description></item><item><title>Appendix A: StdMisc</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdmisc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdmisc/</guid><description>Constants Undefined Entity Implementation
1 2 3 4 // Language: Clean undef :: anyType undef = abort &amp;#34;Run-time error! Program evaluated undefined value?</description></item><item><title>Appendix A: StdOrdList</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdordlist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdordlist/</guid><description>Basic Functions sort Signature
$$ \begin{align*} {A}\rightarrow{R} \end{align*} $$
where:
$A$ and $R$ are of type $[\textbf{T}]$. Additionally, equality and relational operations must be defined on $\textbf{T}$.</description></item><item><title>Appendix A: StdOverloaded</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdoverloaded/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdoverloaded/</guid><description>Operations Addition Signature
$$ \begin{align*} a\rightarrow{b}\rightarrow{R} \end{align*} $$
where:
$a$, $b$, and $R$ are of a generic type. Behavior: adds $a$ and $b$.</description></item><item><title>Appendix A: StdReal</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdreal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdreal/</guid><description>Introduction This section of Appendix A discusses operations and functions defined within Standard Real and, by extension, the Standard Environment.</description></item><item><title>Appendix A: StdString</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdstring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdstring/</guid><description>Basic Operations Concatenation Signature
$$ \begin{align*} A\rightarrow{B}\rightarrow{R} \end{align*} $$
where
$A$, $B$, and $R$ are of type $\textbf{String}$. Behavior: joins$B$ to the end of $A$.</description></item><item><title>Appendix A: StdTuple</title><link>https://eurydia.github.io/cleanpedia/appendix-a/stdtuple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-a/stdtuple/</guid><description>Relational Operations Equal To Signature
$$ \begin{align*} (\textbf{T}, \textbf{K})\rightarrow(\textbf{T}, \textbf{K})\rightarrow{R} \end{align*} $$
or
$$ \begin{align*} (\textbf{T},\textbf{K},\textbf{V})\rightarrow(\textbf{T},\textbf{K},\textbf{V})\rightarrow{R} \end{align*} $$
where:
$R$ is of type $\textbf{Bool}$.</description></item><item><title>Appendix B: Code recipes</title><link>https://eurydia.github.io/cleanpedia/appendix-b/_intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/appendix-b/_intro/</guid><description>Table of contents Introduction Breaking an integer into its digits Computing divisors of an integer Checking if an integer is prime or not Introduction This section contains a collection of common and useful functions.</description></item><item><title>Defining a Function</title><link>https://eurydia.github.io/cleanpedia/function/Defining-a-Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/function/Defining-a-Function/</guid><description>A simple function definition consists of one function implementation. A function can be defined with multiple function implementations as well.</description></item><item><title>Guarded Expressions</title><link>https://eurydia.github.io/cleanpedia/function/Guarded-Expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/function/Guarded-Expressions/</guid><description>Guarded expressions allow a function implementation to have multiple expressions.
Control Form of a Guarded Expression A control implementation with one guarded expression is written as follows.</description></item><item><title>Implementation Rules</title><link>https://eurydia.github.io/cleanpedia/function/Implementation-Rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/function/Implementation-Rules/</guid><description>When defining a function, implementations must obey the following rules to be valid. Otherwise, the function definition results in a compile-time error.</description></item><item><title>Implementing a Function</title><link>https://eurydia.github.io/cleanpedia/function/Implementing-a-Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/function/Implementing-a-Function/</guid><description>As function definitions consist function implementations, let&amp;rsquo;s discuss what a function implementation looks like.
Control Forms of a Function Implementation A control form of a function implementation with one parameter is written as follows.</description></item><item><title>Operator Associativity</title><link>https://eurydia.github.io/cleanpedia/operator/operator-associativity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/operator/operator-associativity/</guid><description>The associativity is important when evaluating two operators of the same precedence.
There are three associativities:
infix for non-associative operators, infixl for left-associative operators, and infixr for right-associative operators.</description></item><item><title>Operator Conflict</title><link>https://eurydia.github.io/cleanpedia/operator/operator-conflict/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/operator/operator-conflict/</guid><description>Operators can conflict with one another.
1 2 3 4 5 6 7 8 9 10 // Language: Clean (&amp;lt;=&amp;gt;) infixl 9 :: Bool Bool -&amp;gt; Bool (&amp;lt;=&amp;gt;) True True = True (&amp;lt;=&amp;gt;) False False = True (&amp;lt;=&amp;gt;) _ _ = False (--&amp;gt;) infixr 9 :: Bool Bool -&amp;gt; Bool (--&amp;gt;) True False = False (--&amp;gt;) _ _ = True It is not allowed to apply operators with equal precedence in an expression in such a way that their associativity conflict.</description></item><item><title>Operator Precedence</title><link>https://eurydia.github.io/cleanpedia/operator/operator-precedence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/operator/operator-precedence/</guid><description>The precedence determines how tightly an operator binds to its argument. Precedence can be between zero and nine with higher number having higher precedence.</description></item><item><title>operator-definition</title><link>https://eurydia.github.io/cleanpedia/operator/operator-definition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/operator/operator-definition/</guid><description>An operator can be defined by placing its name between parentheses. It can be implemented as if it was an ordinary function.</description></item><item><title>Partial Functions</title><link>https://eurydia.github.io/cleanpedia/function/Partial-Functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/function/Partial-Functions/</guid><description>A partially defined function is a function which results in a run-time error when called with values outside of its domain.</description></item><item><title>Typing Operators</title><link>https://eurydia.github.io/cleanpedia/operator/typing-operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://eurydia.github.io/cleanpedia/operator/typing-operators/</guid><description>A control operator definition may be explicitly typed as follows.
1 2 3 4 // Language: Clean (operator) :: paramLType paramRType -&amp;gt; expressionType (operator) paramL paramR = expression In addition, operator associativity (A) and precedence (P) may be specified as well.</description></item></channel></rss>